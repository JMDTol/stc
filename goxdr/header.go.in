// -*-Go-*-

// Don't edit header.go, edit header.go.in.  header.go is
// autogenerated from header.go.in by uncommenting the line marked
// UNCOMMENT.  (The comment makes is easier to edit the contents of
// the header string as go source code in a syntax-aware editor.)

package main

//UNCOMMENT:var header string = `
// begin boilerplate

import "fmt"
import "math"

type XdrError string
func (v XdrError) Error() string { return string(v) }
func xdrPanic(s string, args ...interface{}) {
	panic(XdrError(fmt.Sprintf(s, args...)))
}

type XDR interface {
	Marshal(name string, ptr interface{})
}

type XdrAggregate interface {
	XdrMarshal(XDR, string)
}

type XdrPtr interface {
	XdrAggregate
	GetPresent() bool
	SetPresent(bool)
	XdrMarshalValue(XDR, string)
	XdrPointer() interface{}
	XdrValue() interface{}
}

type XdrVec interface {
	XdrAggregate
	XdrBound() uint32
	SetVecLen(uint32)
	XdrMarshalN(XDR, string, uint32)
	XdrPointer() interface{}
	XdrValue() interface{}
}

const (
	TRUE = true
	FALSE = false
)

type XdrVoid = struct{}

type XdrNum32 interface {
	GetU32() uint32
	SetU32(uint32)
	XdrPointer() interface{}
	XdrValue() interface{}
}

type XdrBool bool
func (v *XdrBool) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrBool) GetU32() uint32 {
	if *v {
		return 1
	}
	return 0
}
func (v *XdrBool) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v = false
	case 1:
		*v = true
	}
	xdrPanic("bool must be 0 or 1")
}
func (v *XdrBool) XdrPointer() interface{} { return (*bool)(v) }
func (v *XdrBool) XdrValue() interface{} { return bool(*v) }
func XDR_bool(x XDR, name string, v *bool) {
	x.Marshal(name, (*XdrBool)(v))
}

type XdrInt32 int32
func (v *XdrInt32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrInt32) GetU32() uint32 { return uint32(*v) }
func (v *XdrInt32) SetU32(nv uint32) { *v = XdrInt32(nv) }
func (v *XdrInt32) XdrPointer() interface{} { return (*int32)(v) }
func (v *XdrInt32) XdrValue() interface{} { return int32(*v) }
func XDR_int32(x XDR, name string, v *int32) {
	x.Marshal(name, (*XdrInt32)(v))
}

type XdrUint32 uint32
func (v *XdrUint32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrUint32) GetU32() uint32 { return uint32(*v) }
func (v *XdrUint32) SetU32(nv uint32) { *v = XdrUint32(nv) }
func (v *XdrUint32) XdrPointer() interface{} { return (*uint32)(v) }
func (v *XdrUint32) XdrValue() interface{} { return uint32(*v) }
func XDR_uint32(x XDR, name string, v *uint32) {
	x.Marshal(name, (*XdrUint32)(v))
}

type XdrFloat32 float32
func (v *XdrFloat32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrFloat32) GetU32() uint32 {
	return math.Float32bits(float32(*v))
}
func (v *XdrFloat32) SetU32(nv uint32) {
	*v = XdrFloat32(math.Float32frombits(nv))
}
func (v *XdrFloat32) XdrPointer() interface{} { return (*float32)(v) }
func (v *XdrFloat32) XdrValue() interface{} { return float32(*v) }
func XDR_float32(x XDR, name string, v *float32) {
	x.Marshal(name, (*XdrFloat32)(v))
}

type XdrSize struct {
	size uint32
	bound uint32
}
func (v *XdrSize) String() string { return fmt.Sprintf("%v", v.size) }
func (v *XdrSize) GetU32() uint32 { return v.size }
func (v *XdrSize) SetU32(nv uint32) {
	if nv > v.bound {
		xdrPanic("size %d greater than bound %d", nv, v.bound)
	} else if int(nv) < 0 {
		xdrPanic("size %d greater than max slice len", nv)
	}
	v.size = nv
}
func (v *XdrSize) XdrPointer() interface{} { return &v.size }
func (v *XdrSize) XdrValue() interface{} { return v.size }
func (v *XdrSize) XdrBound() uint32 { return v.bound }

type XdrNum64 interface {
	GetU64() uint64
	SetU64(uint64)
	XdrPointer() interface{}
	XdrValue() interface{}
}

type XdrInt64 int64
func (v *XdrInt64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrInt64) GetU64() uint64 { return uint64(*v) }
func (v *XdrInt64) SetU64(nv uint64) { *v = XdrInt64(nv) }
func (v *XdrInt64) XdrPointer() interface{} { return (*int64)(v) }
func (v *XdrInt64) XdrValue() interface{} { return int64(*v) }
func XDR_int64(x XDR, name string, v *int64) {
	x.Marshal(name, (*XdrInt64)(v))
}

type XdrUint64 uint64
func (v *XdrUint64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrUint64) GetU64() uint64 { return uint64(*v) }
func (v *XdrUint64) SetU64(nv uint64) { *v = XdrUint64(nv) }
func (v *XdrUint64) XdrPointer() interface{} { return (*uint64)(v) }
func (v *XdrUint64) XdrValue() interface{} { return uint64(*v) }
func XDR_uint64(x XDR, name string, v *uint64) {
	x.Marshal(name, (*XdrUint64)(v))
}

type XdrFloat64 float64
func (v *XdrFloat64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrFloat64) GetU64() uint64 {
	return math.Float64bits(float64(*v))
}
func (v *XdrFloat64) SetU64(nv uint64) {
	*v = XdrFloat64(math.Float64frombits(nv))
}
func (v *XdrFloat64) XdrPointer() interface{} { return (*float64)(v) }
func (v *XdrFloat64) XdrValue() interface{} { return float64(*v) }
func XDR_float64(x XDR, name string, v *float64) {
	x.Marshal(name, (*XdrFloat64)(v))
}

type XdrBytes interface {
	GetByteSlice() []byte
	XdrValue() interface{}
}
type XdrVarBytes interface {
	XdrBytes
	XdrBound() uint32
	SetByteSlice([]byte)
	XdrPointer() interface{}
}

type XdrString struct {
	Str *string
	Bound uint32
}
func (v *XdrString) String() string { return fmt.Sprintf("%q", *v.Str) }
func (v *XdrString) GetByteSlice() []byte { return ([]byte)(*v.Str) }
func (v *XdrString) XdrBound() uint32 { return v.Bound }
func (v *XdrString) SetByteSlice(bs []byte) {
	if uintptr(len(bs)) > uintptr(v.Bound) {
		xdrPanic("Cannot store %d bytes in string<%d>", len(bs), v.Bound)
	}
	*v.Str = string(bs)
}
func (v *XdrString) XdrPointer() interface{} { return v.Str }
func (v *XdrString) XdrValue() interface{} { return *v.Str }

type XdrVecOpaque struct {
	Bytes *[]byte
	Bound uint32
}
func (v *XdrVecOpaque) String() string { return fmt.Sprintf("%v", *v.Bytes) }
func (v *XdrVecOpaque) GetByteSlice() []byte { return *v.Bytes }
func (v *XdrVecOpaque) XdrBound() uint32 { return v.Bound }
func (v *XdrVecOpaque) SetByteSlice(bs []byte) {
	if uintptr(len(bs)) > uintptr(v.Bound) {
		xdrPanic("Cannot store %d bytes in string<%d>", len(bs), v.Bound)
	}
	*v.Bytes = bs
}
func (v *XdrVecOpaque) XdrPointer() interface{} { return v.Bytes }
func (v *XdrVecOpaque) XdrValue() interface{} { return *v.Bytes }

type XdrArrayOpaque []byte
func (v XdrArrayOpaque) GetByteSlice() []byte { return ([]byte)(v) }
func (v XdrArrayOpaque) XdrValue() interface{} { return v }

// end boilerplate
//UNCOMMENT:`
