// Code generated by goxdr -p stx -enum-comments -o stx/xdr_generated.go~ xdr/Stellar-SCP.x xdr/Stellar-ledger-entries.x xdr/Stellar-ledger.x xdr/Stellar-overlay.x xdr/Stellar-transaction.x xdr/Stellar-types.x; DO NOT EDIT.

package stx
import "fmt"
import "context"
import . "github.com/xdrpp/goxdr/xdr"

var _ XDR
var _ = fmt.Sprintf
var _ context.Context

//
// Data types defined in XDR file
//

type Value = []byte

type SCPBallot struct {
	// n
	Counter Uint32
	// x
	Value Value
}

type SCPStatementType int32
const (
	SCP_ST_PREPARE SCPStatementType = 0
	SCP_ST_CONFIRM SCPStatementType = 1
	SCP_ST_EXTERNALIZE SCPStatementType = 2
	SCP_ST_NOMINATE SCPStatementType = 3
)

type SCPNomination struct {
	// D
	QuorumSetHash Hash
	// X
	Votes []Value
	// Y
	Accepted []Value
}

type XdrAnon_SCPStatement_Pledges_Prepare struct {
	// D
	QuorumSetHash Hash
	// b
	Ballot SCPBallot
	// p
	Prepared *SCPBallot
	// p'
	PreparedPrime *SCPBallot
	// c.n
	NC Uint32
	// h.n
	NH Uint32
}
type XdrAnon_SCPStatement_Pledges_Confirm struct {
	// b
	Ballot SCPBallot
	// p.n
	NPrepared Uint32
	// c.n
	NCommit Uint32
	// h.n
	NH Uint32
	// D
	QuorumSetHash Hash
}
type XdrAnon_SCPStatement_Pledges_Externalize struct {
	// c
	Commit SCPBallot
	// h.n
	NH Uint32
	// D used before EXTERNALIZE
	CommitQuorumSetHash Hash
}
type XdrAnon_SCPStatement_Pledges struct {
	// The union discriminant Type selects among the following arms:
	//   SCP_ST_PREPARE:
	//      Prepare() *XdrAnon_SCPStatement_Pledges_Prepare
	//   SCP_ST_CONFIRM:
	//      Confirm() *XdrAnon_SCPStatement_Pledges_Confirm
	//   SCP_ST_EXTERNALIZE:
	//      Externalize() *XdrAnon_SCPStatement_Pledges_Externalize
	//   SCP_ST_NOMINATE:
	//      Nominate() *SCPNomination
	Type SCPStatementType
	_u interface{}
}
type SCPStatement struct {
	// v
	NodeID NodeID
	// i
	SlotIndex Uint64
	Pledges XdrAnon_SCPStatement_Pledges
}

type SCPEnvelope struct {
	Statement SCPStatement
	Signature Signature
}

// supports things like: A,B,C,(D,E,F),(G,H,(I,J,K,L))
// only allows 2 levels of nesting
type SCPQuorumSet struct {
	Threshold Uint32
	Validators []PublicKey
	InnerSets []SCPQuorumSet
}

type AccountID = PublicKey

type Thresholds = [4]byte

type String32 = string // bound 32

type String64 = string // bound 64

type SequenceNumber = Int64

type TimePoint = Uint64

type DataValue = []byte // bound 64

// 1-4 alphanumeric characters right-padded with 0 bytes
type AssetCode4 = [4]byte

// 5-12 alphanumeric characters right-padded with 0 bytes
type AssetCode12 = [12]byte

type AssetType int32
const (
	ASSET_TYPE_NATIVE AssetType = 0
	ASSET_TYPE_CREDIT_ALPHANUM4 AssetType = 1
	ASSET_TYPE_CREDIT_ALPHANUM12 AssetType = 2
)

type XdrAnon_Asset_AlphaNum4 struct {
	AssetCode AssetCode4
	Issuer AccountID
}
type XdrAnon_Asset_AlphaNum12 struct {
	AssetCode AssetCode12
	Issuer AccountID
}
type Asset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_NATIVE:
	//      void
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AlphaNum4() *XdrAnon_Asset_AlphaNum4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AlphaNum12() *XdrAnon_Asset_AlphaNum12
	Type AssetType
	_u interface{}
}

// price in fractional representation
type Price struct {
	// numerator
	N Int32
	// denominator
	D Int32
}

type Liabilities struct {
	Buying Int64
	Selling Int64
}

// the 'Thresholds' type is packed uint8_t values
// defined by these indexes
type ThresholdIndexes int32
const (
	THRESHOLD_MASTER_WEIGHT ThresholdIndexes = 0
	THRESHOLD_LOW ThresholdIndexes = 1
	THRESHOLD_MED ThresholdIndexes = 2
	THRESHOLD_HIGH ThresholdIndexes = 3
)

type LedgerEntryType int32
const (
	ACCOUNT LedgerEntryType = 0
	TRUSTLINE LedgerEntryType = 1
	OFFER LedgerEntryType = 2
	DATA LedgerEntryType = 3
)

type Signer struct {
	Key SignerKey
	// really only need 1 byte
	Weight Uint32
}

type AccountFlags int32
const (
	// Flags set on issuer accounts
	// TrustLines are created with authorized set to "false" requiring
	// the issuer to set it for each TrustLine
	AUTH_REQUIRED_FLAG AccountFlags = AccountFlags(0x1)
	// If set, the authorized flag in TrustLines can be cleared
	// otherwise, authorization cannot be revoked
	AUTH_REVOCABLE_FLAG AccountFlags = AccountFlags(0x2)
	// Once set, causes all AUTH_* flags to be read-only
	AUTH_IMMUTABLE_FLAG AccountFlags = AccountFlags(0x4)
)

const MASK_ACCOUNT_FLAGS = 0x7

type XdrAnon_AccountEntry_Ext_V1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type XdrAnon_AccountEntry_Ext_V1 struct {
	Liabilities Liabilities
	Ext XdrAnon_AccountEntry_Ext_V1_Ext
}
// reserved for future use
type XdrAnon_AccountEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *XdrAnon_AccountEntry_Ext_V1
	V int32
	_u interface{}
}
type AccountEntry struct {
	// master public key for this account
	AccountID AccountID
	// in stroops
	Balance Int64
	// last sequence number used for this account
	SeqNum SequenceNumber
	// number of sub-entries this account has
	NumSubEntries Uint32
	// drives the reserve
	InflationDest *AccountID
	// see AccountFlags
	Flags Uint32
	// can be used for reverse federation and memo lookup
	HomeDomain String32
	// fields used for signatures
	// thresholds stores unsigned bytes: [weight of master|low|medium|high]
	Thresholds Thresholds
	// possible signers for this account
	Signers []Signer // bound 20
	Ext XdrAnon_AccountEntry_Ext
}

type TrustLineFlags int32
const (
	// issuer has authorized account to perform transactions with its credit
	AUTHORIZED_FLAG TrustLineFlags = 1
)

const MASK_TRUSTLINE_FLAGS = 1

type XdrAnon_TrustLineEntry_Ext_V1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type XdrAnon_TrustLineEntry_Ext_V1 struct {
	Liabilities Liabilities
	Ext XdrAnon_TrustLineEntry_Ext_V1_Ext
}
// reserved for future use
type XdrAnon_TrustLineEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *XdrAnon_TrustLineEntry_Ext_V1
	V int32
	_u interface{}
}
type TrustLineEntry struct {
	// account this trustline belongs to
	AccountID AccountID
	// type of asset (with issuer)
	Asset Asset
	// how much of this asset the user has.
	Balance Int64
	// balance cannot be above this
	Limit Int64
	// see TrustLineFlags
	Flags Uint32
	Ext XdrAnon_TrustLineEntry_Ext
}

type OfferEntryFlags int32
const (
	// issuer has authorized account to perform transactions with its credit
	PASSIVE_FLAG OfferEntryFlags = 1
)

const MASK_OFFERENTRY_FLAGS = 1

// reserved for future use
type XdrAnon_OfferEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type OfferEntry struct {
	SellerID AccountID
	OfferID Int64
	// A
	Selling Asset
	// B
	Buying Asset
	// amount of A
	Amount Int64
	Price Price
	// see OfferEntryFlags
	Flags Uint32
	Ext XdrAnon_OfferEntry_Ext
}

// reserved for future use
type XdrAnon_DataEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type DataEntry struct {
	// account this data belongs to
	AccountID AccountID
	DataName String64
	DataValue DataValue
	Ext XdrAnon_DataEntry_Ext
}

type XdrAnon_LedgerEntry_Data struct {
	// The union discriminant Type selects among the following arms:
	//   ACCOUNT:
	//      Account() *AccountEntry
	//   TRUSTLINE:
	//      TrustLine() *TrustLineEntry
	//   OFFER:
	//      Offer() *OfferEntry
	//   DATA:
	//      Data() *DataEntry
	Type LedgerEntryType
	_u interface{}
}
// reserved for future use
type XdrAnon_LedgerEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type LedgerEntry struct {
	// ledger the LedgerEntry was last changed
	LastModifiedLedgerSeq Uint32
	Data XdrAnon_LedgerEntry_Data
	Ext XdrAnon_LedgerEntry_Ext
}

// list of all envelope types used in the application
// those are prefixes used when building signatures for
// the respective envelopes
type EnvelopeType int32
const (
	ENVELOPE_TYPE_SCP EnvelopeType = 1
	ENVELOPE_TYPE_TX EnvelopeType = 2
	ENVELOPE_TYPE_AUTH EnvelopeType = 3
	ENVELOPE_TYPE_SCPVALUE EnvelopeType = 4
)

type UpgradeType = []byte // bound 128

type StellarValueType int32
const (
	STELLAR_VALUE_BASIC StellarValueType = 0
	STELLAR_VALUE_SIGNED StellarValueType = 1
)

type LedgerCloseValueSignature struct {
	// which node introduced the value
	NodeID NodeID
	// nodeID's signature
	Signature Signature
}

// reserved for future use
type XdrAnon_StellarValue_Ext struct {
	// The union discriminant V selects among the following arms:
	//   STELLAR_VALUE_BASIC:
	//      void
	//   STELLAR_VALUE_SIGNED:
	//      LcValueSignature() *LedgerCloseValueSignature
	V StellarValueType
	_u interface{}
}
type StellarValue struct {
	// transaction set to apply to previous ledger
	TxSetHash Hash
	// network close time
	CloseTime TimePoint
	// upgrades to apply to the previous ledger (usually empty)
	// this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
	// unknown steps during consensus if needed.
	// see notes below on 'LedgerUpgrade' for more detail
	// max size is dictated by number of upgrade types (+ room for future)
	Upgrades []UpgradeType // bound 6
	Ext XdrAnon_StellarValue_Ext
}

// reserved for future use
type XdrAnon_LedgerHeader_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type LedgerHeader struct {
	// the protocol version of the ledger
	LedgerVersion Uint32
	// hash of the previous ledger header
	PreviousLedgerHash Hash
	// what consensus agreed to
	ScpValue StellarValue
	// the TransactionResultSet that led to this ledger
	TxSetResultHash Hash
	// hash of the ledger state
	BucketListHash Hash
	// sequence number of this ledger
	LedgerSeq Uint32
	// total number of stroops in existence.
	TotalCoins Int64
	// fees burned since last inflation run
	FeePool Int64
	// inflation sequence number
	InflationSeq Uint32
	// last used global ID, used for generating objects
	IdPool Uint64
	// base fee per operation in stroops
	BaseFee Uint32
	// account base reserve in stroops
	BaseReserve Uint32
	// maximum size a transaction set can be
	MaxTxSetSize Uint32
	// hashes of ledgers in the past. allows you to jump back
	SkipList [4]Hash
	Ext XdrAnon_LedgerHeader_Ext
}

type LedgerUpgradeType int32
const (
	LEDGER_UPGRADE_VERSION LedgerUpgradeType = 1
	LEDGER_UPGRADE_BASE_FEE LedgerUpgradeType = 2
	LEDGER_UPGRADE_MAX_TX_SET_SIZE LedgerUpgradeType = 3
	LEDGER_UPGRADE_BASE_RESERVE LedgerUpgradeType = 4
)

type LedgerUpgrade struct {
	// The union discriminant Type selects among the following arms:
	//   LEDGER_UPGRADE_VERSION:
	//      NewLedgerVersion() *Uint32
	//   LEDGER_UPGRADE_BASE_FEE:
	//      NewBaseFee() *Uint32
	//   LEDGER_UPGRADE_MAX_TX_SET_SIZE:
	//      NewMaxTxSetSize() *Uint32
	//   LEDGER_UPGRADE_BASE_RESERVE:
	//      NewBaseReserve() *Uint32
	Type LedgerUpgradeType
	_u interface{}
}

type XdrAnon_LedgerKey_Account struct {
	AccountID AccountID
}
type XdrAnon_LedgerKey_TrustLine struct {
	AccountID AccountID
	Asset Asset
}
type XdrAnon_LedgerKey_Offer struct {
	SellerID AccountID
	OfferID Int64
}
type XdrAnon_LedgerKey_Data struct {
	AccountID AccountID
	DataName String64
}
type LedgerKey struct {
	// The union discriminant Type selects among the following arms:
	//   ACCOUNT:
	//      Account() *XdrAnon_LedgerKey_Account
	//   TRUSTLINE:
	//      TrustLine() *XdrAnon_LedgerKey_TrustLine
	//   OFFER:
	//      Offer() *XdrAnon_LedgerKey_Offer
	//   DATA:
	//      Data() *XdrAnon_LedgerKey_Data
	Type LedgerEntryType
	_u interface{}
}

type BucketEntryType int32
const (
	// At-and-after protocol 11: bucket metadata, should come first.
	METAENTRY BucketEntryType = -1
	// Before protocol 11: created-or-updated;
	LIVEENTRY BucketEntryType = 0
	// At-and-after protocol 11: only updated.
	DEADENTRY BucketEntryType = 1
	// At-and-after protocol 11: only created.
	INITENTRY BucketEntryType = 2
)

// reserved for future use
type XdrAnon_BucketMetadata_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type BucketMetadata struct {
	// Indicates the protocol version used to create / merge this bucket.
	LedgerVersion Uint32
	Ext XdrAnon_BucketMetadata_Ext
}

type BucketEntry struct {
	// The union discriminant Type selects among the following arms:
	//   LIVEENTRY, INITENTRY:
	//      LiveEntry() *LedgerEntry
	//   DEADENTRY:
	//      DeadEntry() *LedgerKey
	//   METAENTRY:
	//      MetaEntry() *BucketMetadata
	Type BucketEntryType
	_u interface{}
}

// Transaction sets are the unit used by SCP to decide on transitions
// between ledgers
type TransactionSet struct {
	PreviousLedgerHash Hash
	Txs []TransactionEnvelope
}

type TransactionResultPair struct {
	TransactionHash Hash
	// result for the transaction
	Result TransactionResult
}

// TransactionResultSet is used to recover results between ledgers
type TransactionResultSet struct {
	Results []TransactionResultPair
}

// reserved for future use
type XdrAnon_TransactionHistoryEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type TransactionHistoryEntry struct {
	LedgerSeq Uint32
	TxSet TransactionSet
	Ext XdrAnon_TransactionHistoryEntry_Ext
}

// reserved for future use
type XdrAnon_TransactionHistoryResultEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type TransactionHistoryResultEntry struct {
	LedgerSeq Uint32
	TxResultSet TransactionResultSet
	Ext XdrAnon_TransactionHistoryResultEntry_Ext
}

// reserved for future use
type XdrAnon_LedgerHeaderHistoryEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type LedgerHeaderHistoryEntry struct {
	Hash Hash
	Header LedgerHeader
	Ext XdrAnon_LedgerHeaderHistoryEntry_Ext
}

type LedgerSCPMessages struct {
	LedgerSeq Uint32
	Messages []SCPEnvelope
}

// note: ledgerMessages may refer to any quorumSets encountered
// in the file so far, not just the one from this entry
type SCPHistoryEntryV0 struct {
	// additional quorum sets used by ledgerMessages
	QuorumSets []SCPQuorumSet
	LedgerMessages LedgerSCPMessages
}

// SCP history file is an array of these
type SCPHistoryEntry struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *SCPHistoryEntryV0
	V int32
	_u interface{}
}

type LedgerEntryChangeType int32
const (
	// entry was added to the ledger
	LEDGER_ENTRY_CREATED LedgerEntryChangeType = 0
	// entry was modified in the ledger
	LEDGER_ENTRY_UPDATED LedgerEntryChangeType = 1
	// entry was removed from the ledger
	LEDGER_ENTRY_REMOVED LedgerEntryChangeType = 2
	// value of the entry
	LEDGER_ENTRY_STATE LedgerEntryChangeType = 3
)

type LedgerEntryChange struct {
	// The union discriminant Type selects among the following arms:
	//   LEDGER_ENTRY_CREATED:
	//      Created() *LedgerEntry
	//   LEDGER_ENTRY_UPDATED:
	//      Updated() *LedgerEntry
	//   LEDGER_ENTRY_REMOVED:
	//      Removed() *LedgerKey
	//   LEDGER_ENTRY_STATE:
	//      State() *LedgerEntry
	Type LedgerEntryChangeType
	_u interface{}
}

type LedgerEntryChanges = []LedgerEntryChange

type OperationMeta struct {
	Changes LedgerEntryChanges
}

type TransactionMetaV1 struct {
	// tx level changes if any
	TxChanges LedgerEntryChanges
	// meta for each operation
	Operations []OperationMeta
}

type TransactionMetaV2 struct {
	// tx level changes before operations
	TxChangesBefore LedgerEntryChanges
	// are applied if any
	Operations []OperationMeta
	// tx level changes after operations are
	TxChangesAfter LedgerEntryChanges
}

// this is the meta produced when applying transactions
// it does not include pre-apply updates such as fees
type TransactionMeta struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      Operations() *[]OperationMeta
	//   1:
	//      V1() *TransactionMetaV1
	//   2:
	//      V2() *TransactionMetaV2
	V int32
	_u interface{}
}

type ErrorCode int32
const (
	// Unspecific error
	ERR_MISC ErrorCode = 0
	// Malformed data
	ERR_DATA ErrorCode = 1
	// Misconfiguration error
	ERR_CONF ErrorCode = 2
	// Authentication failure
	ERR_AUTH ErrorCode = 3
	// System overloaded
	ERR_LOAD ErrorCode = 4
)

type Error struct {
	Code ErrorCode
	Msg string // bound 100
}

type AuthCert struct {
	Pubkey Curve25519Public
	Expiration Uint64
	Sig Signature
}

type Hello struct {
	LedgerVersion Uint32
	OverlayVersion Uint32
	OverlayMinVersion Uint32
	NetworkID Hash
	VersionStr string // bound 100
	ListeningPort int32
	PeerID NodeID
	Cert AuthCert
	Nonce Uint256
}

type Auth struct {
	// Empty message, just to confirm
	// establishment of MAC keys.
	Unused int32
}

type IPAddrType int32
const (
	IPv4 IPAddrType = 0
	IPv6 IPAddrType = 1
)

type XdrAnon_PeerAddress_Ip struct {
	// The union discriminant Type selects among the following arms:
	//   IPv4:
	//      Ipv4() *[4]byte
	//   IPv6:
	//      Ipv6() *[16]byte
	Type IPAddrType
	_u interface{}
}
type PeerAddress struct {
	Ip XdrAnon_PeerAddress_Ip
	Port Uint32
	NumFailures Uint32
}

type MessageType int32
const (
	ERROR_MSG MessageType = 0
	AUTH MessageType = 2
	DONT_HAVE MessageType = 3
	// gets a list of peers this guy knows about
	GET_PEERS MessageType = 4
	PEERS MessageType = 5
	// gets a particular txset by hash
	GET_TX_SET MessageType = 6
	TX_SET MessageType = 7
	// pass on a tx you have heard about
	TRANSACTION MessageType = 8
	// SCP
	GET_SCP_QUORUMSET MessageType = 9
	SCP_QUORUMSET MessageType = 10
	SCP_MESSAGE MessageType = 11
	GET_SCP_STATE MessageType = 12
	// new messages
	HELLO MessageType = 13
)

type DontHave struct {
	Type MessageType
	ReqHash Uint256
}

type StellarMessage struct {
	// The union discriminant Type selects among the following arms:
	//   ERROR_MSG:
	//      Error() *Error
	//   HELLO:
	//      Hello() *Hello
	//   AUTH:
	//      Auth() *Auth
	//   DONT_HAVE:
	//      DontHave() *DontHave
	//   GET_PEERS:
	//      void
	//   PEERS:
	//      Peers() *[]PeerAddress // bound 100
	//   GET_TX_SET:
	//      TxSetHash() *Uint256
	//   TX_SET:
	//      TxSet() *TransactionSet
	//   TRANSACTION:
	//      Transaction() *TransactionEnvelope
	//   GET_SCP_QUORUMSET:
	//      QSetHash() *Uint256
	//   SCP_QUORUMSET:
	//      QSet() *SCPQuorumSet
	//   SCP_MESSAGE:
	//      Envelope() *SCPEnvelope
	//   GET_SCP_STATE:
	//      GetSCPLedgerSeq() *Uint32
	Type MessageType
	_u interface{}
}

type XdrAnon_AuthenticatedMessage_V0 struct {
	Sequence Uint64
	Message StellarMessage
	Mac HmacSha256Mac
}
type AuthenticatedMessage struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *XdrAnon_AuthenticatedMessage_V0
	V Uint32
	_u interface{}
}

type DecoratedSignature struct {
	// last 4 bytes of the public key, used as a hint
	Hint SignatureHint
	// actual signature
	Signature Signature
}

type OperationType int32
const (
	CREATE_ACCOUNT OperationType = 0
	PAYMENT OperationType = 1
	PATH_PAYMENT_STRICT_RECEIVE OperationType = 2
	MANAGE_SELL_OFFER OperationType = 3
	CREATE_PASSIVE_SELL_OFFER OperationType = 4
	SET_OPTIONS OperationType = 5
	CHANGE_TRUST OperationType = 6
	ALLOW_TRUST OperationType = 7
	ACCOUNT_MERGE OperationType = 8
	INFLATION OperationType = 9
	MANAGE_DATA OperationType = 10
	BUMP_SEQUENCE OperationType = 11
	MANAGE_BUY_OFFER OperationType = 12
	PATH_PAYMENT_STRICT_SEND OperationType = 13
)

type CreateAccountOp struct {
	// account to create
	Destination AccountID
	// amount they end up with
	StartingBalance Int64
}

type PaymentOp struct {
	// recipient of the payment
	Destination AccountID
	// what they end up with
	Asset Asset
	// amount they end up with
	Amount Int64
}

type PathPaymentStrictReceiveOp struct {
	// asset we pay with
	SendAsset Asset
	// the maximum amount of sendAsset to
	SendMax Int64
	// recipient of the payment
	Destination AccountID
	// what they end up with
	DestAsset Asset
	// amount they end up with
	DestAmount Int64
	// additional hops it must go through to get there
	Path []Asset // bound 5
}

type PathPaymentStrictSendOp struct {
	// asset we pay with
	SendAsset Asset
	// amount of sendAsset to send (excluding fees)
	SendAmount Int64
	// recipient of the payment
	Destination AccountID
	// what they end up with
	DestAsset Asset
	// the minimum amount of dest asset to
	DestMin Int64
	// additional hops it must go through to get there
	Path []Asset // bound 5
}

type ManageSellOfferOp struct {
	Selling Asset
	Buying Asset
	// amount being sold. if set to 0, delete the offer
	Amount Int64
	// price of thing being sold in terms of what you are buying
	Price Price
	// 0=create a new offer, otherwise edit an existing offer
	OfferID Int64
}

type ManageBuyOfferOp struct {
	Selling Asset
	Buying Asset
	// amount being bought. if set to 0, delete the offer
	BuyAmount Int64
	// price of thing being bought in terms of what you are
	Price Price
	// 0=create a new offer, otherwise edit an existing offer
	OfferID Int64
}

type CreatePassiveSellOfferOp struct {
	// A
	Selling Asset
	// B
	Buying Asset
	// amount taker gets. if set to 0, delete the offer
	Amount Int64
	// cost of A in terms of B
	Price Price
}

type SetOptionsOp struct {
	// sets the inflation destination
	InflationDest *AccountID
	// which flags to clear
	ClearFlags *Uint32
	// which flags to set
	SetFlags *Uint32
	// account threshold manipulation
	MasterWeight *Uint32
	LowThreshold *Uint32
	MedThreshold *Uint32
	HighThreshold *Uint32
	// sets the home domain
	HomeDomain *String32
	// Add, update or remove a signer for the account
	// signer is deleted if the weight is 0
	Signer *Signer
}

type ChangeTrustOp struct {
	Line Asset
	// if limit is set to 0, deletes the trust line
	Limit Int64
}

type XdrAnon_AllowTrustOp_Asset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AssetCode4() *AssetCode4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AssetCode12() *AssetCode12
	Type AssetType
	_u interface{}
}
type AllowTrustOp struct {
	Trustor AccountID
	Asset XdrAnon_AllowTrustOp_Asset
	Authorize bool
}

type ManageDataOp struct {
	DataName String64
	// set to null to clear
	DataValue *DataValue
}

type BumpSequenceOp struct {
	BumpTo SequenceNumber
}

type XdrAnon_Operation_Body struct {
	// The union discriminant Type selects among the following arms:
	//   CREATE_ACCOUNT:
	//      CreateAccountOp() *CreateAccountOp
	//   PAYMENT:
	//      PaymentOp() *PaymentOp
	//   PATH_PAYMENT_STRICT_RECEIVE:
	//      PathPaymentStrictReceiveOp() *PathPaymentStrictReceiveOp
	//   MANAGE_SELL_OFFER:
	//      ManageSellOfferOp() *ManageSellOfferOp
	//   CREATE_PASSIVE_SELL_OFFER:
	//      CreatePassiveSellOfferOp() *CreatePassiveSellOfferOp
	//   SET_OPTIONS:
	//      SetOptionsOp() *SetOptionsOp
	//   CHANGE_TRUST:
	//      ChangeTrustOp() *ChangeTrustOp
	//   ALLOW_TRUST:
	//      AllowTrustOp() *AllowTrustOp
	//   ACCOUNT_MERGE:
	//      Destination() *AccountID
	//   INFLATION:
	//      void
	//   MANAGE_DATA:
	//      ManageDataOp() *ManageDataOp
	//   BUMP_SEQUENCE:
	//      BumpSequenceOp() *BumpSequenceOp
	//   MANAGE_BUY_OFFER:
	//      ManageBuyOfferOp() *ManageBuyOfferOp
	//   PATH_PAYMENT_STRICT_SEND:
	//      PathPaymentStrictSendOp() *PathPaymentStrictSendOp
	Type OperationType
	_u interface{}
}
/* An operation is the lowest unit of work that a transaction does */
type Operation struct {
	// sourceAccount is the account used to run the operation
	// if not set, the runtime defaults to "sourceAccount" specified at
	// the transaction level
	SourceAccount *AccountID
	Body XdrAnon_Operation_Body
}

type MemoType int32
const (
	MEMO_NONE MemoType = 0
	MEMO_TEXT MemoType = 1
	MEMO_ID MemoType = 2
	MEMO_HASH MemoType = 3
	MEMO_RETURN MemoType = 4
)

type Memo struct {
	// The union discriminant Type selects among the following arms:
	//   MEMO_NONE:
	//      void
	//   MEMO_TEXT:
	//      Text() *string // bound 28
	//   MEMO_ID:
	//      Id() *Uint64
	//   MEMO_HASH:
	//      Hash() *Hash
	//   MEMO_RETURN:
	//      RetHash() *Hash
	Type MemoType
	_u interface{}
}

type TimeBounds struct {
	MinTime TimePoint
	// 0 here means no maxTime
	MaxTime TimePoint
}

const MAX_OPS_PER_TX = 100

// reserved for future use
type XdrAnon_Transaction_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type Transaction struct {
	// account used to run the transaction
	SourceAccount AccountID
	// the fee the sourceAccount will pay
	Fee Uint32
	// sequence number to consume in the account
	SeqNum SequenceNumber
	// validity range (inclusive) for the last ledger close time
	TimeBounds *TimeBounds
	Memo Memo
	Operations []Operation // bound MAX_OPS_PER_TX
	Ext XdrAnon_Transaction_Ext
}

type XdrAnon_TransactionSignaturePayload_TaggedTransaction struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_TX:
	//      Tx() *Transaction
	Type EnvelopeType
	_u interface{}
}
type TransactionSignaturePayload struct {
	NetworkId Hash
	TaggedTransaction XdrAnon_TransactionSignaturePayload_TaggedTransaction
}

/* A TransactionEnvelope wraps a transaction with signatures. */
type TransactionEnvelope struct {
	Tx Transaction
	Signatures []DecoratedSignature // bound 20
}

/* This result is used when offers are taken during an operation */
type ClaimOfferAtom struct {
	// emitted to identify the offer
	SellerID AccountID
	OfferID Int64
	// amount and asset taken from the owner
	AssetSold Asset
	AmountSold Int64
	// amount and asset sent to the owner
	AssetBought Asset
	AmountBought Int64
}

type CreateAccountResultCode int32
const (
	// account was created
	CREATE_ACCOUNT_SUCCESS CreateAccountResultCode = 0
	// invalid destination
	CREATE_ACCOUNT_MALFORMED CreateAccountResultCode = -1
	// not enough funds in source account
	CREATE_ACCOUNT_UNDERFUNDED CreateAccountResultCode = -2
	// would create an account below the min reserve
	CREATE_ACCOUNT_LOW_RESERVE CreateAccountResultCode = -3
	// account already exists
	CREATE_ACCOUNT_ALREADY_EXIST CreateAccountResultCode = -4
)

type CreateAccountResult struct {
	// The union discriminant Code selects among the following arms:
	//   CREATE_ACCOUNT_SUCCESS:
	//      void
	//   default:
	//      void
	Code CreateAccountResultCode
	_u interface{}
}

type PaymentResultCode int32
const (
	// payment successfuly completed
	PAYMENT_SUCCESS PaymentResultCode = 0
	// bad input
	PAYMENT_MALFORMED PaymentResultCode = -1
	// not enough funds in source account
	PAYMENT_UNDERFUNDED PaymentResultCode = -2
	// no trust line on source account
	PAYMENT_SRC_NO_TRUST PaymentResultCode = -3
	// source not authorized to transfer
	PAYMENT_SRC_NOT_AUTHORIZED PaymentResultCode = -4
	// destination account does not exist
	PAYMENT_NO_DESTINATION PaymentResultCode = -5
	// destination missing a trust line for asset
	PAYMENT_NO_TRUST PaymentResultCode = -6
	// destination not authorized to hold asset
	PAYMENT_NOT_AUTHORIZED PaymentResultCode = -7
	// destination would go above their limit
	PAYMENT_LINE_FULL PaymentResultCode = -8
	// missing issuer on asset
	PAYMENT_NO_ISSUER PaymentResultCode = -9
)

type PaymentResult struct {
	// The union discriminant Code selects among the following arms:
	//   PAYMENT_SUCCESS:
	//      void
	//   default:
	//      void
	Code PaymentResultCode
	_u interface{}
}

type PathPaymentStrictReceiveResultCode int32
const (
	// success
	PATH_PAYMENT_STRICT_RECEIVE_SUCCESS PathPaymentStrictReceiveResultCode = 0
	// bad input
	PATH_PAYMENT_STRICT_RECEIVE_MALFORMED PathPaymentStrictReceiveResultCode = -1
	// not enough funds in source account
	PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED PathPaymentStrictReceiveResultCode = -2
	// no trust line on source account
	PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST PathPaymentStrictReceiveResultCode = -3
	// source not authorized to transfer
	PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED PathPaymentStrictReceiveResultCode = -4
	// destination account does not exist
	PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION PathPaymentStrictReceiveResultCode = -5
	// dest missing a trust line for asset
	PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST PathPaymentStrictReceiveResultCode = -6
	// dest not authorized to hold asset
	PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED PathPaymentStrictReceiveResultCode = -7
	// dest would go above their limit
	PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL PathPaymentStrictReceiveResultCode = -8
	// missing issuer on one asset
	PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER PathPaymentStrictReceiveResultCode = -9
	// not enough offers to satisfy path
	PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS PathPaymentStrictReceiveResultCode = -10
	// would cross one of its own offers
	PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF PathPaymentStrictReceiveResultCode = -11
	// could not satisfy sendmax
	PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX PathPaymentStrictReceiveResultCode = -12
)

type SimplePaymentResult struct {
	Destination AccountID
	Asset Asset
	Amount Int64
}

type XdrAnon_PathPaymentStrictReceiveResult_Success struct {
	Offers []ClaimOfferAtom
	Last SimplePaymentResult
}
type PathPaymentStrictReceiveResult struct {
	// The union discriminant Code selects among the following arms:
	//   PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
	//      Success() *XdrAnon_PathPaymentStrictReceiveResult_Success
	//   PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
	//      NoIssuer() *Asset
	//   default:
	//      void
	Code PathPaymentStrictReceiveResultCode
	_u interface{}
}

type PathPaymentStrictSendResultCode int32
const (
	// success
	PATH_PAYMENT_STRICT_SEND_SUCCESS PathPaymentStrictSendResultCode = 0
	// bad input
	PATH_PAYMENT_STRICT_SEND_MALFORMED PathPaymentStrictSendResultCode = -1
	// not enough funds in source account
	PATH_PAYMENT_STRICT_SEND_UNDERFUNDED PathPaymentStrictSendResultCode = -2
	// no trust line on source account
	PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST PathPaymentStrictSendResultCode = -3
	// source not authorized to transfer
	PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED PathPaymentStrictSendResultCode = -4
	// destination account does not exist
	PATH_PAYMENT_STRICT_SEND_NO_DESTINATION PathPaymentStrictSendResultCode = -5
	// dest missing a trust line for asset
	PATH_PAYMENT_STRICT_SEND_NO_TRUST PathPaymentStrictSendResultCode = -6
	// dest not authorized to hold asset
	PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED PathPaymentStrictSendResultCode = -7
	// dest would go above their limit
	PATH_PAYMENT_STRICT_SEND_LINE_FULL PathPaymentStrictSendResultCode = -8
	// missing issuer on one asset
	PATH_PAYMENT_STRICT_SEND_NO_ISSUER PathPaymentStrictSendResultCode = -9
	// not enough offers to satisfy path
	PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS PathPaymentStrictSendResultCode = -10
	// would cross one of its own offers
	PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF PathPaymentStrictSendResultCode = -11
	// could not satisfy destMin
	PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN PathPaymentStrictSendResultCode = -12
)

type XdrAnon_PathPaymentStrictSendResult_Success struct {
	Offers []ClaimOfferAtom
	Last SimplePaymentResult
}
type PathPaymentStrictSendResult struct {
	// The union discriminant Code selects among the following arms:
	//   PATH_PAYMENT_STRICT_SEND_SUCCESS:
	//      Success() *XdrAnon_PathPaymentStrictSendResult_Success
	//   PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
	//      NoIssuer() *Asset
	//   default:
	//      void
	Code PathPaymentStrictSendResultCode
	_u interface{}
}

type ManageSellOfferResultCode int32
const (
	// codes considered as "success" for the operation
	MANAGE_SELL_OFFER_SUCCESS ManageSellOfferResultCode = 0
	// generated offer would be invalid
	MANAGE_SELL_OFFER_MALFORMED ManageSellOfferResultCode = -1
	// no trust line for what we're selling
	MANAGE_SELL_OFFER_SELL_NO_TRUST ManageSellOfferResultCode = -2
	// no trust line for what we're buying
	MANAGE_SELL_OFFER_BUY_NO_TRUST ManageSellOfferResultCode = -3
	// not authorized to sell
	MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED ManageSellOfferResultCode = -4
	// not authorized to buy
	MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED ManageSellOfferResultCode = -5
	// can't receive more of what it's buying
	MANAGE_SELL_OFFER_LINE_FULL ManageSellOfferResultCode = -6
	// doesn't hold what it's trying to sell
	MANAGE_SELL_OFFER_UNDERFUNDED ManageSellOfferResultCode = -7
	// would cross an offer from the same user
	MANAGE_SELL_OFFER_CROSS_SELF ManageSellOfferResultCode = -8
	// no issuer for what we're selling
	MANAGE_SELL_OFFER_SELL_NO_ISSUER ManageSellOfferResultCode = -9
	// no issuer for what we're buying
	MANAGE_SELL_OFFER_BUY_NO_ISSUER ManageSellOfferResultCode = -10
	// offerID does not match an existing offer
	MANAGE_SELL_OFFER_NOT_FOUND ManageSellOfferResultCode = -11
	// not enough funds to create a new Offer
	MANAGE_SELL_OFFER_LOW_RESERVE ManageSellOfferResultCode = -12
)

type ManageOfferEffect int32
const (
	MANAGE_OFFER_CREATED ManageOfferEffect = 0
	MANAGE_OFFER_UPDATED ManageOfferEffect = 1
	MANAGE_OFFER_DELETED ManageOfferEffect = 2
)

type XdrAnon_ManageOfferSuccessResult_Offer struct {
	// The union discriminant Effect selects among the following arms:
	//   MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
	//      Offer() *OfferEntry
	//   default:
	//      void
	Effect ManageOfferEffect
	_u interface{}
}
type ManageOfferSuccessResult struct {
	// offers that got claimed while creating this offer
	OffersClaimed []ClaimOfferAtom
	Offer XdrAnon_ManageOfferSuccessResult_Offer
}

type ManageSellOfferResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_SELL_OFFER_SUCCESS:
	//      Success() *ManageOfferSuccessResult
	//   default:
	//      void
	Code ManageSellOfferResultCode
	_u interface{}
}

type ManageBuyOfferResultCode int32
const (
	// codes considered as "success" for the operation
	MANAGE_BUY_OFFER_SUCCESS ManageBuyOfferResultCode = 0
	// generated offer would be invalid
	MANAGE_BUY_OFFER_MALFORMED ManageBuyOfferResultCode = -1
	// no trust line for what we're selling
	MANAGE_BUY_OFFER_SELL_NO_TRUST ManageBuyOfferResultCode = -2
	// no trust line for what we're buying
	MANAGE_BUY_OFFER_BUY_NO_TRUST ManageBuyOfferResultCode = -3
	// not authorized to sell
	MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED ManageBuyOfferResultCode = -4
	// not authorized to buy
	MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED ManageBuyOfferResultCode = -5
	// can't receive more of what it's buying
	MANAGE_BUY_OFFER_LINE_FULL ManageBuyOfferResultCode = -6
	// doesn't hold what it's trying to sell
	MANAGE_BUY_OFFER_UNDERFUNDED ManageBuyOfferResultCode = -7
	// would cross an offer from the same user
	MANAGE_BUY_OFFER_CROSS_SELF ManageBuyOfferResultCode = -8
	// no issuer for what we're selling
	MANAGE_BUY_OFFER_SELL_NO_ISSUER ManageBuyOfferResultCode = -9
	// no issuer for what we're buying
	MANAGE_BUY_OFFER_BUY_NO_ISSUER ManageBuyOfferResultCode = -10
	// offerID does not match an existing offer
	MANAGE_BUY_OFFER_NOT_FOUND ManageBuyOfferResultCode = -11
	// not enough funds to create a new Offer
	MANAGE_BUY_OFFER_LOW_RESERVE ManageBuyOfferResultCode = -12
)

type ManageBuyOfferResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_BUY_OFFER_SUCCESS:
	//      Success() *ManageOfferSuccessResult
	//   default:
	//      void
	Code ManageBuyOfferResultCode
	_u interface{}
}

type SetOptionsResultCode int32
const (
	// codes considered as "success" for the operation
	SET_OPTIONS_SUCCESS SetOptionsResultCode = 0
	// not enough funds to add a signer
	SET_OPTIONS_LOW_RESERVE SetOptionsResultCode = -1
	// max number of signers already reached
	SET_OPTIONS_TOO_MANY_SIGNERS SetOptionsResultCode = -2
	// invalid combination of clear/set flags
	SET_OPTIONS_BAD_FLAGS SetOptionsResultCode = -3
	// inflation account does not exist
	SET_OPTIONS_INVALID_INFLATION SetOptionsResultCode = -4
	// can no longer change this option
	SET_OPTIONS_CANT_CHANGE SetOptionsResultCode = -5
	// can't set an unknown flag
	SET_OPTIONS_UNKNOWN_FLAG SetOptionsResultCode = -6
	// bad value for weight/threshold
	SET_OPTIONS_THRESHOLD_OUT_OF_RANGE SetOptionsResultCode = -7
	// signer cannot be masterkey
	SET_OPTIONS_BAD_SIGNER SetOptionsResultCode = -8
	// malformed home domain
	SET_OPTIONS_INVALID_HOME_DOMAIN SetOptionsResultCode = -9
)

type SetOptionsResult struct {
	// The union discriminant Code selects among the following arms:
	//   SET_OPTIONS_SUCCESS:
	//      void
	//   default:
	//      void
	Code SetOptionsResultCode
	_u interface{}
}

type ChangeTrustResultCode int32
const (
	// codes considered as "success" for the operation
	CHANGE_TRUST_SUCCESS ChangeTrustResultCode = 0
	// bad input
	CHANGE_TRUST_MALFORMED ChangeTrustResultCode = -1
	// could not find issuer
	CHANGE_TRUST_NO_ISSUER ChangeTrustResultCode = -2
	// cannot drop limit below balance
	CHANGE_TRUST_INVALID_LIMIT ChangeTrustResultCode = -3
	// not enough funds to create a new trust line,
	CHANGE_TRUST_LOW_RESERVE ChangeTrustResultCode = -4
	// trusting self is not allowed
	CHANGE_TRUST_SELF_NOT_ALLOWED ChangeTrustResultCode = -5
)

type ChangeTrustResult struct {
	// The union discriminant Code selects among the following arms:
	//   CHANGE_TRUST_SUCCESS:
	//      void
	//   default:
	//      void
	Code ChangeTrustResultCode
	_u interface{}
}

type AllowTrustResultCode int32
const (
	// codes considered as "success" for the operation
	ALLOW_TRUST_SUCCESS AllowTrustResultCode = 0
	// asset is not ASSET_TYPE_ALPHANUM
	ALLOW_TRUST_MALFORMED AllowTrustResultCode = -1
	// trustor does not have a trustline
	ALLOW_TRUST_NO_TRUST_LINE AllowTrustResultCode = -2
	// source account does not require trust
	ALLOW_TRUST_TRUST_NOT_REQUIRED AllowTrustResultCode = -3
	// source account can't revoke trust,
	ALLOW_TRUST_CANT_REVOKE AllowTrustResultCode = -4
	// trusting self is not allowed
	ALLOW_TRUST_SELF_NOT_ALLOWED AllowTrustResultCode = -5
)

type AllowTrustResult struct {
	// The union discriminant Code selects among the following arms:
	//   ALLOW_TRUST_SUCCESS:
	//      void
	//   default:
	//      void
	Code AllowTrustResultCode
	_u interface{}
}

type AccountMergeResultCode int32
const (
	// codes considered as "success" for the operation
	ACCOUNT_MERGE_SUCCESS AccountMergeResultCode = 0
	// can't merge onto itself
	ACCOUNT_MERGE_MALFORMED AccountMergeResultCode = -1
	// destination does not exist
	ACCOUNT_MERGE_NO_ACCOUNT AccountMergeResultCode = -2
	// source account has AUTH_IMMUTABLE set
	ACCOUNT_MERGE_IMMUTABLE_SET AccountMergeResultCode = -3
	// account has trust lines/offers
	ACCOUNT_MERGE_HAS_SUB_ENTRIES AccountMergeResultCode = -4
	// sequence number is over max allowed
	ACCOUNT_MERGE_SEQNUM_TOO_FAR AccountMergeResultCode = -5
	// can't add source balance to
	ACCOUNT_MERGE_DEST_FULL AccountMergeResultCode = -6
)

type AccountMergeResult struct {
	// The union discriminant Code selects among the following arms:
	//   ACCOUNT_MERGE_SUCCESS:
	//      SourceAccountBalance() *Int64
	//   default:
	//      void
	Code AccountMergeResultCode
	_u interface{}
}

type InflationResultCode int32
const (
	// codes considered as "success" for the operation
	INFLATION_SUCCESS InflationResultCode = 0
	// codes considered as "failure" for the operation
	INFLATION_NOT_TIME InflationResultCode = -1
)

type InflationPayout struct {
	Destination AccountID
	Amount Int64
}

type InflationResult struct {
	// The union discriminant Code selects among the following arms:
	//   INFLATION_SUCCESS:
	//      Payouts() *[]InflationPayout
	//   default:
	//      void
	Code InflationResultCode
	_u interface{}
}

type ManageDataResultCode int32
const (
	// codes considered as "success" for the operation
	MANAGE_DATA_SUCCESS ManageDataResultCode = 0
	// The network hasn't moved to this protocol change yet
	MANAGE_DATA_NOT_SUPPORTED_YET ManageDataResultCode = -1
	// Trying to remove a Data Entry that isn't there
	MANAGE_DATA_NAME_NOT_FOUND ManageDataResultCode = -2
	// not enough funds to create a new Data Entry
	MANAGE_DATA_LOW_RESERVE ManageDataResultCode = -3
	// Name not a valid string
	MANAGE_DATA_INVALID_NAME ManageDataResultCode = -4
)

type ManageDataResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_DATA_SUCCESS:
	//      void
	//   default:
	//      void
	Code ManageDataResultCode
	_u interface{}
}

type BumpSequenceResultCode int32
const (
	// codes considered as "success" for the operation
	BUMP_SEQUENCE_SUCCESS BumpSequenceResultCode = 0
	// codes considered as "failure" for the operation
	BUMP_SEQUENCE_BAD_SEQ BumpSequenceResultCode = -1
)

type BumpSequenceResult struct {
	// The union discriminant Code selects among the following arms:
	//   BUMP_SEQUENCE_SUCCESS:
	//      void
	//   default:
	//      void
	Code BumpSequenceResultCode
	_u interface{}
}

type OperationResultCode int32
const (
	// inner object result is valid
	OpINNER OperationResultCode = 0
	// too few valid signatures / wrong network
	OpBAD_AUTH OperationResultCode = -1
	// source account was not found
	OpNO_ACCOUNT OperationResultCode = -2
	// operation not supported at this time
	OpNOT_SUPPORTED OperationResultCode = -3
	// max number of subentries already reached
	OpTOO_MANY_SUBENTRIES OperationResultCode = -4
	// operation did too much work
	OpEXCEEDED_WORK_LIMIT OperationResultCode = -5
)

type XdrAnon_OperationResult_Tr struct {
	// The union discriminant Type selects among the following arms:
	//   CREATE_ACCOUNT:
	//      CreateAccountResult() *CreateAccountResult
	//   PAYMENT:
	//      PaymentResult() *PaymentResult
	//   PATH_PAYMENT_STRICT_RECEIVE:
	//      PathPaymentStrictReceiveResult() *PathPaymentStrictReceiveResult
	//   MANAGE_SELL_OFFER:
	//      ManageSellOfferResult() *ManageSellOfferResult
	//   CREATE_PASSIVE_SELL_OFFER:
	//      CreatePassiveSellOfferResult() *ManageSellOfferResult
	//   SET_OPTIONS:
	//      SetOptionsResult() *SetOptionsResult
	//   CHANGE_TRUST:
	//      ChangeTrustResult() *ChangeTrustResult
	//   ALLOW_TRUST:
	//      AllowTrustResult() *AllowTrustResult
	//   ACCOUNT_MERGE:
	//      AccountMergeResult() *AccountMergeResult
	//   INFLATION:
	//      InflationResult() *InflationResult
	//   MANAGE_DATA:
	//      ManageDataResult() *ManageDataResult
	//   BUMP_SEQUENCE:
	//      BumpSeqResult() *BumpSequenceResult
	//   MANAGE_BUY_OFFER:
	//      ManageBuyOfferResult() *ManageBuyOfferResult
	//   PATH_PAYMENT_STRICT_SEND:
	//      PathPaymentStrictSendResult() *PathPaymentStrictSendResult
	Type OperationType
	_u interface{}
}
type OperationResult struct {
	// The union discriminant Code selects among the following arms:
	//   OpINNER:
	//      Tr() *XdrAnon_OperationResult_Tr
	//   default:
	//      void
	Code OperationResultCode
	_u interface{}
}

type TransactionResultCode int32
const (
	// all operations succeeded
	TxSUCCESS TransactionResultCode = 0
	// one of the operations failed (none were applied)
	TxFAILED TransactionResultCode = -1
	// ledger closeTime before minTime
	TxTOO_EARLY TransactionResultCode = -2
	// ledger closeTime after maxTime
	TxTOO_LATE TransactionResultCode = -3
	// no operation was specified
	TxMISSING_OPERATION TransactionResultCode = -4
	// sequence number does not match source account
	TxBAD_SEQ TransactionResultCode = -5
	// too few valid signatures / wrong network
	TxBAD_AUTH TransactionResultCode = -6
	// fee would bring account below reserve
	TxINSUFFICIENT_BALANCE TransactionResultCode = -7
	// source account not found
	TxNO_ACCOUNT TransactionResultCode = -8
	// fee is too small
	TxINSUFFICIENT_FEE TransactionResultCode = -9
	// unused signatures attached to transaction
	TxBAD_AUTH_EXTRA TransactionResultCode = -10
	// an unknown error occured
	TxINTERNAL_ERROR TransactionResultCode = -11
)

type XdrAnon_TransactionResult_Result struct {
	// The union discriminant Code selects among the following arms:
	//   TxSUCCESS, TxFAILED:
	//      Results() *[]OperationResult
	//   default:
	//      void
	Code TransactionResultCode
	_u interface{}
}
// reserved for future use
type XdrAnon_TransactionResult_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V int32
	_u interface{}
}
type TransactionResult struct {
	// actual fee charged for the transaction
	FeeCharged Int64
	Result XdrAnon_TransactionResult_Result
	Ext XdrAnon_TransactionResult_Ext
}

type Hash = [32]byte

type Uint256 = [32]byte

type Uint32 = uint32

type Int32 = int32

type Uint64 = uint64

type Int64 = int64

type CryptoKeyType int32
const (
	KEY_TYPE_ED25519 CryptoKeyType = 0
	KEY_TYPE_PRE_AUTH_TX CryptoKeyType = 1
	KEY_TYPE_HASH_X CryptoKeyType = 2
)

type PublicKeyType int32
const (
	PUBLIC_KEY_TYPE_ED25519 PublicKeyType = PublicKeyType(KEY_TYPE_ED25519)
)

type SignerKeyType int32
const (
	SIGNER_KEY_TYPE_ED25519 SignerKeyType = SignerKeyType(KEY_TYPE_ED25519)
	SIGNER_KEY_TYPE_PRE_AUTH_TX SignerKeyType = SignerKeyType(KEY_TYPE_PRE_AUTH_TX)
	SIGNER_KEY_TYPE_HASH_X SignerKeyType = SignerKeyType(KEY_TYPE_HASH_X)
)

type PublicKey struct {
	// The union discriminant Type selects among the following arms:
	//   PUBLIC_KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	Type PublicKeyType
	_u interface{}
}

type SignerKey struct {
	// The union discriminant Type selects among the following arms:
	//   SIGNER_KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	//   SIGNER_KEY_TYPE_PRE_AUTH_TX:
	//      PreAuthTx() *Uint256
	//   SIGNER_KEY_TYPE_HASH_X:
	//      HashX() *Uint256
	Type SignerKeyType
	_u interface{}
}

// variable size as the size depends on the signature scheme used
type Signature = []byte // bound 64

type SignatureHint = [4]byte

type NodeID = PublicKey

type Curve25519Secret struct {
	Key [32]byte
}

type Curve25519Public struct {
	Key [32]byte
}

type HmacSha256Key struct {
	Key [32]byte
}

type HmacSha256Mac struct {
	Mac [32]byte
}

//
// Helper types and generated marshaling functions
//

type _XdrTypedef_Value struct {
	p *Value
}
func (v _XdrTypedef_Value) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Value) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Value) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Value(string, *Value)
	}); ok {
		xs.Marshal_Value(name, v.p)
	} else {
		x.Marshal(name, XdrVecOpaque{v.p, 0xffffffff})
	}
}
func XDR_Value(v *Value) _XdrTypedef_Value {
	return _XdrTypedef_Value{ v }
}
func (v *SCPBallot) XdrPointer() interface{} { return v }
func (v SCPBallot) XdrValue() interface{} { return v }
func (v *SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPBallot) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.Counter).XdrMarshal(x, x.Sprintf("%scounter", name))
	XDR_Value(&v.Value).XdrMarshal(x, x.Sprintf("%svalue", name))
}
func XDR_SCPBallot(v *SCPBallot) *SCPBallot { return v }
var _XdrNames_SCPStatementType = map[int32]string{
	int32(SCP_ST_PREPARE): "SCP_ST_PREPARE",
	int32(SCP_ST_CONFIRM): "SCP_ST_CONFIRM",
	int32(SCP_ST_EXTERNALIZE): "SCP_ST_EXTERNALIZE",
	int32(SCP_ST_NOMINATE): "SCP_ST_NOMINATE",
}
var _XdrValues_SCPStatementType = map[string]int32{
	"SCP_ST_PREPARE": int32(SCP_ST_PREPARE),
	"SCP_ST_CONFIRM": int32(SCP_ST_CONFIRM),
	"SCP_ST_EXTERNALIZE": int32(SCP_ST_EXTERNALIZE),
	"SCP_ST_NOMINATE": int32(SCP_ST_NOMINATE),
}
func (SCPStatementType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCPStatementType
}
func (v SCPStatementType) String() string {
	if s, ok := _XdrNames_SCPStatementType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCPStatementType#%d", v)
}
func (v *SCPStatementType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCPStatementType[stok]; ok {
			*v = SCPStatementType(val)
			return nil
		} else if stok == "SCPStatementType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCPStatementType.", stok))
	}
}
func (v SCPStatementType) GetU32() uint32 { return uint32(v) }
func (v *SCPStatementType) SetU32(n uint32) { *v = SCPStatementType(n) }
func (v *SCPStatementType) XdrPointer() interface{} { return v }
func (v SCPStatementType) XdrValue() interface{} { return v }
func (v *SCPStatementType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_SCPStatementType(v *SCPStatementType) *SCPStatementType { return v }
type _XdrVec_unbounded_Value []Value
func (_XdrVec_unbounded_Value) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Value) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Value length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Value length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Value) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Value) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Value, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Value) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Value(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Value) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_Value) XdrPointer() interface{} { return (*[]Value)(v) }
func (v _XdrVec_unbounded_Value) XdrValue() interface{} { return ([]Value)(v) }
func (v *_XdrVec_unbounded_Value) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPNomination) XdrPointer() interface{} { return v }
func (v SCPNomination) XdrValue() interface{} { return v }
func (v *SCPNomination) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPNomination) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(&v.QuorumSetHash).XdrMarshal(x, x.Sprintf("%squorumSetHash", name))
	x.Marshal(x.Sprintf("%svotes", name), (*_XdrVec_unbounded_Value)(&v.Votes))
	x.Marshal(x.Sprintf("%saccepted", name), (*_XdrVec_unbounded_Value)(&v.Accepted))
}
func XDR_SCPNomination(v *SCPNomination) *SCPNomination { return v }
type _XdrPtr_SCPBallot struct {
	p **SCPBallot
}
type _ptrflag_SCPBallot _XdrPtr_SCPBallot
func (v _ptrflag_SCPBallot) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCPBallot) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SCPBallot flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SCPBallot) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCPBallot) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCPBallot)
		}
	default:
		XdrPanic("*SCPBallot present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_SCPBallot) XdrPointer() interface{} { return nil }
func (v _ptrflag_SCPBallot) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SCPBallot) XdrBound() uint32 { return 1 }
func (v _XdrPtr_SCPBallot) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_SCPBallot) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCPBallot)
	}
}
func (v _XdrPtr_SCPBallot) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCPBallot(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SCPBallot) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCPBallot(v))
	v.XdrMarshalValue(x, name)
}
func (v _XdrPtr_SCPBallot) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SCPBallot) XdrValue() interface{} { return *v.p }
func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrPointer() interface{} { return v }
func (v XdrAnon_SCPStatement_Pledges_Prepare) XdrValue() interface{} { return v }
func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(&v.QuorumSetHash).XdrMarshal(x, x.Sprintf("%squorumSetHash", name))
	XDR_SCPBallot(&v.Ballot).XdrMarshal(x, x.Sprintf("%sballot", name))
	x.Marshal(x.Sprintf("%sprepared", name), _XdrPtr_SCPBallot{&v.Prepared})
	x.Marshal(x.Sprintf("%spreparedPrime", name), _XdrPtr_SCPBallot{&v.PreparedPrime})
	XDR_Uint32(&v.NC).XdrMarshal(x, x.Sprintf("%snC", name))
	XDR_Uint32(&v.NH).XdrMarshal(x, x.Sprintf("%snH", name))
}
func XDR_XdrAnon_SCPStatement_Pledges_Prepare(v *XdrAnon_SCPStatement_Pledges_Prepare) *XdrAnon_SCPStatement_Pledges_Prepare { return v }
func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrPointer() interface{} { return v }
func (v XdrAnon_SCPStatement_Pledges_Confirm) XdrValue() interface{} { return v }
func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPBallot(&v.Ballot).XdrMarshal(x, x.Sprintf("%sballot", name))
	XDR_Uint32(&v.NPrepared).XdrMarshal(x, x.Sprintf("%snPrepared", name))
	XDR_Uint32(&v.NCommit).XdrMarshal(x, x.Sprintf("%snCommit", name))
	XDR_Uint32(&v.NH).XdrMarshal(x, x.Sprintf("%snH", name))
	XDR_Hash(&v.QuorumSetHash).XdrMarshal(x, x.Sprintf("%squorumSetHash", name))
}
func XDR_XdrAnon_SCPStatement_Pledges_Confirm(v *XdrAnon_SCPStatement_Pledges_Confirm) *XdrAnon_SCPStatement_Pledges_Confirm { return v }
func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrPointer() interface{} { return v }
func (v XdrAnon_SCPStatement_Pledges_Externalize) XdrValue() interface{} { return v }
func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPBallot(&v.Commit).XdrMarshal(x, x.Sprintf("%scommit", name))
	XDR_Uint32(&v.NH).XdrMarshal(x, x.Sprintf("%snH", name))
	XDR_Hash(&v.CommitQuorumSetHash).XdrMarshal(x, x.Sprintf("%scommitQuorumSetHash", name))
}
func XDR_XdrAnon_SCPStatement_Pledges_Externalize(v *XdrAnon_SCPStatement_Pledges_Externalize) *XdrAnon_SCPStatement_Pledges_Externalize { return v }
func (u *XdrAnon_SCPStatement_Pledges) Prepare() *XdrAnon_SCPStatement_Pledges_Prepare {
	switch u.Type {
	case SCP_ST_PREPARE:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Prepare); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Prepare
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Prepare accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Confirm() *XdrAnon_SCPStatement_Pledges_Confirm {
	switch u.Type {
	case SCP_ST_CONFIRM:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Confirm); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Confirm
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Confirm accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Externalize() *XdrAnon_SCPStatement_Pledges_Externalize {
	switch u.Type {
	case SCP_ST_EXTERNALIZE:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Externalize); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Externalize
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Externalize accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Nominate() *SCPNomination {
	switch u.Type {
	case SCP_ST_NOMINATE:
		if v, ok := u._u.(*SCPNomination); ok {
			return v
		} else {
			var zero SCPNomination
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Nominate accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_SCPStatement_Pledges) XdrValid() bool {
	switch u.Type {
	case SCP_ST_PREPARE,SCP_ST_CONFIRM,SCP_ST_EXTERNALIZE,SCP_ST_NOMINATE:
		return true
	}
	return false
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionBody() interface{} {
	switch u.Type {
	case SCP_ST_PREPARE:
		return u.Prepare()
	case SCP_ST_CONFIRM:
		return u.Confirm()
	case SCP_ST_EXTERNALIZE:
		return u.Externalize()
	case SCP_ST_NOMINATE:
		return u.Nominate()
	}
	return nil
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionBodyName() string {
	switch u.Type {
	case SCP_ST_PREPARE:
		return "Prepare"
	case SCP_ST_CONFIRM:
		return "Confirm"
	case SCP_ST_EXTERNALIZE:
		return "Externalize"
	case SCP_ST_NOMINATE:
		return "Nominate"
	}
	return ""
}
func (v *XdrAnon_SCPStatement_Pledges) XdrPointer() interface{} { return v }
func (v XdrAnon_SCPStatement_Pledges) XdrValue() interface{} { return v }
func (v *XdrAnon_SCPStatement_Pledges) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_SCPStatement_Pledges) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPStatementType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCP_ST_PREPARE:
		XDR_XdrAnon_SCPStatement_Pledges_Prepare(u.Prepare()).XdrMarshal(x, x.Sprintf("%sprepare", name))
		return
	case SCP_ST_CONFIRM:
		XDR_XdrAnon_SCPStatement_Pledges_Confirm(u.Confirm()).XdrMarshal(x, x.Sprintf("%sconfirm", name))
		return
	case SCP_ST_EXTERNALIZE:
		XDR_XdrAnon_SCPStatement_Pledges_Externalize(u.Externalize()).XdrMarshal(x, x.Sprintf("%sexternalize", name))
		return
	case SCP_ST_NOMINATE:
		XDR_SCPNomination(u.Nominate()).XdrMarshal(x, x.Sprintf("%snominate", name))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_SCPStatement_Pledges", u.Type)
}
func XDR_XdrAnon_SCPStatement_Pledges(v *XdrAnon_SCPStatement_Pledges) *XdrAnon_SCPStatement_Pledges { return v}
func (v *SCPStatement) XdrPointer() interface{} { return v }
func (v SCPStatement) XdrValue() interface{} { return v }
func (v *SCPStatement) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPStatement) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_NodeID(&v.NodeID).XdrMarshal(x, x.Sprintf("%snodeID", name))
	XDR_Uint64(&v.SlotIndex).XdrMarshal(x, x.Sprintf("%sslotIndex", name))
	XDR_XdrAnon_SCPStatement_Pledges(&v.Pledges).XdrMarshal(x, x.Sprintf("%spledges", name))
}
func XDR_SCPStatement(v *SCPStatement) *SCPStatement { return v }
func (v *SCPEnvelope) XdrPointer() interface{} { return v }
func (v SCPEnvelope) XdrValue() interface{} { return v }
func (v *SCPEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPStatement(&v.Statement).XdrMarshal(x, x.Sprintf("%sstatement", name))
	XDR_Signature(&v.Signature).XdrMarshal(x, x.Sprintf("%ssignature", name))
}
func XDR_SCPEnvelope(v *SCPEnvelope) *SCPEnvelope { return v }
type _XdrVec_unbounded_PublicKey []PublicKey
func (_XdrVec_unbounded_PublicKey) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_PublicKey) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_PublicKey length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_PublicKey length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_PublicKey) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_PublicKey) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PublicKey, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_PublicKey) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_PublicKey(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_PublicKey) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_PublicKey) XdrPointer() interface{} { return (*[]PublicKey)(v) }
func (v _XdrVec_unbounded_PublicKey) XdrValue() interface{} { return ([]PublicKey)(v) }
func (v *_XdrVec_unbounded_PublicKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type _XdrVec_unbounded_SCPQuorumSet []SCPQuorumSet
func (_XdrVec_unbounded_SCPQuorumSet) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPQuorumSet) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPQuorumSet length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPQuorumSet length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPQuorumSet) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPQuorumSet) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPQuorumSet, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_SCPQuorumSet(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrPointer() interface{} { return (*[]SCPQuorumSet)(v) }
func (v _XdrVec_unbounded_SCPQuorumSet) XdrValue() interface{} { return ([]SCPQuorumSet)(v) }
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPQuorumSet) XdrPointer() interface{} { return v }
func (v SCPQuorumSet) XdrValue() interface{} { return v }
func (v *SCPQuorumSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPQuorumSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.Threshold).XdrMarshal(x, x.Sprintf("%sthreshold", name))
	x.Marshal(x.Sprintf("%svalidators", name), (*_XdrVec_unbounded_PublicKey)(&v.Validators))
	x.Marshal(x.Sprintf("%sinnerSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.InnerSets))
}
func XDR_SCPQuorumSet(v *SCPQuorumSet) *SCPQuorumSet { return v }
type _XdrTypedef_AccountID struct {
	p *AccountID
}
func (v _XdrTypedef_AccountID) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_AccountID) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_AccountID) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_AccountID(string, *AccountID)
	}); ok {
		xs.Marshal_AccountID(name, v.p)
	} else {
		XDR_PublicKey(v.p).XdrMarshal(x, name)
	}
}
func XDR_AccountID(v *AccountID) _XdrTypedef_AccountID {
	return _XdrTypedef_AccountID{ v }
}
type _XdrTypedef_Thresholds struct {
	p *Thresholds
}
func (v _XdrTypedef_Thresholds) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Thresholds) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Thresholds) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Thresholds(string, *Thresholds)
	}); ok {
		xs.Marshal_Thresholds(name, v.p)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v.p)[:]))
	}
}
func XDR_Thresholds(v *Thresholds) _XdrTypedef_Thresholds {
	return _XdrTypedef_Thresholds{ v }
}
type _XdrTypedef_String32 struct {
	p *String32
}
func (v _XdrTypedef_String32) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_String32) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_String32) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_String32(string, *String32)
	}); ok {
		xs.Marshal_String32(name, v.p)
	} else {
		x.Marshal(name, XdrString{v.p, 32})
	}
}
func XDR_String32(v *String32) _XdrTypedef_String32 {
	return _XdrTypedef_String32{ v }
}
type _XdrTypedef_String64 struct {
	p *String64
}
func (v _XdrTypedef_String64) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_String64) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_String64) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_String64(string, *String64)
	}); ok {
		xs.Marshal_String64(name, v.p)
	} else {
		x.Marshal(name, XdrString{v.p, 64})
	}
}
func XDR_String64(v *String64) _XdrTypedef_String64 {
	return _XdrTypedef_String64{ v }
}
type _XdrTypedef_SequenceNumber struct {
	p *SequenceNumber
}
func (v _XdrTypedef_SequenceNumber) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_SequenceNumber) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_SequenceNumber) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_SequenceNumber(string, *SequenceNumber)
	}); ok {
		xs.Marshal_SequenceNumber(name, v.p)
	} else {
		XDR_Int64(v.p).XdrMarshal(x, name)
	}
}
func XDR_SequenceNumber(v *SequenceNumber) _XdrTypedef_SequenceNumber {
	return _XdrTypedef_SequenceNumber{ v }
}
type _XdrTypedef_TimePoint struct {
	p *TimePoint
}
func (v _XdrTypedef_TimePoint) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_TimePoint) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_TimePoint) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_TimePoint(string, *TimePoint)
	}); ok {
		xs.Marshal_TimePoint(name, v.p)
	} else {
		XDR_Uint64(v.p).XdrMarshal(x, name)
	}
}
func XDR_TimePoint(v *TimePoint) _XdrTypedef_TimePoint {
	return _XdrTypedef_TimePoint{ v }
}
type _XdrTypedef_DataValue struct {
	p *DataValue
}
func (v _XdrTypedef_DataValue) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_DataValue) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_DataValue) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_DataValue(string, *DataValue)
	}); ok {
		xs.Marshal_DataValue(name, v.p)
	} else {
		x.Marshal(name, XdrVecOpaque{v.p, 64})
	}
}
func XDR_DataValue(v *DataValue) _XdrTypedef_DataValue {
	return _XdrTypedef_DataValue{ v }
}
type _XdrTypedef_AssetCode4 struct {
	p *AssetCode4
}
func (v _XdrTypedef_AssetCode4) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_AssetCode4) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_AssetCode4) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_AssetCode4(string, *AssetCode4)
	}); ok {
		xs.Marshal_AssetCode4(name, v.p)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v.p)[:]))
	}
}
func XDR_AssetCode4(v *AssetCode4) _XdrTypedef_AssetCode4 {
	return _XdrTypedef_AssetCode4{ v }
}
type _XdrTypedef_AssetCode12 struct {
	p *AssetCode12
}
func (v _XdrTypedef_AssetCode12) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_AssetCode12) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_AssetCode12) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_AssetCode12(string, *AssetCode12)
	}); ok {
		xs.Marshal_AssetCode12(name, v.p)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v.p)[:]))
	}
}
func XDR_AssetCode12(v *AssetCode12) _XdrTypedef_AssetCode12 {
	return _XdrTypedef_AssetCode12{ v }
}
var _XdrNames_AssetType = map[int32]string{
	int32(ASSET_TYPE_NATIVE): "ASSET_TYPE_NATIVE",
	int32(ASSET_TYPE_CREDIT_ALPHANUM4): "ASSET_TYPE_CREDIT_ALPHANUM4",
	int32(ASSET_TYPE_CREDIT_ALPHANUM12): "ASSET_TYPE_CREDIT_ALPHANUM12",
}
var _XdrValues_AssetType = map[string]int32{
	"ASSET_TYPE_NATIVE": int32(ASSET_TYPE_NATIVE),
	"ASSET_TYPE_CREDIT_ALPHANUM4": int32(ASSET_TYPE_CREDIT_ALPHANUM4),
	"ASSET_TYPE_CREDIT_ALPHANUM12": int32(ASSET_TYPE_CREDIT_ALPHANUM12),
}
func (AssetType) XdrEnumNames() map[int32]string {
	return _XdrNames_AssetType
}
func (v AssetType) String() string {
	if s, ok := _XdrNames_AssetType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AssetType#%d", v)
}
func (v *AssetType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AssetType[stok]; ok {
			*v = AssetType(val)
			return nil
		} else if stok == "AssetType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AssetType.", stok))
	}
}
func (v AssetType) GetU32() uint32 { return uint32(v) }
func (v *AssetType) SetU32(n uint32) { *v = AssetType(n) }
func (v *AssetType) XdrPointer() interface{} { return v }
func (v AssetType) XdrValue() interface{} { return v }
func (v *AssetType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_AssetType(v *AssetType) *AssetType { return v }
func (v *XdrAnon_Asset_AlphaNum4) XdrPointer() interface{} { return v }
func (v XdrAnon_Asset_AlphaNum4) XdrValue() interface{} { return v }
func (v *XdrAnon_Asset_AlphaNum4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_Asset_AlphaNum4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetCode4(&v.AssetCode).XdrMarshal(x, x.Sprintf("%sassetCode", name))
	XDR_AccountID(&v.Issuer).XdrMarshal(x, x.Sprintf("%sissuer", name))
}
func XDR_XdrAnon_Asset_AlphaNum4(v *XdrAnon_Asset_AlphaNum4) *XdrAnon_Asset_AlphaNum4 { return v }
func (v *XdrAnon_Asset_AlphaNum12) XdrPointer() interface{} { return v }
func (v XdrAnon_Asset_AlphaNum12) XdrValue() interface{} { return v }
func (v *XdrAnon_Asset_AlphaNum12) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_Asset_AlphaNum12) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetCode12(&v.AssetCode).XdrMarshal(x, x.Sprintf("%sassetCode", name))
	XDR_AccountID(&v.Issuer).XdrMarshal(x, x.Sprintf("%sissuer", name))
}
func XDR_XdrAnon_Asset_AlphaNum12(v *XdrAnon_Asset_AlphaNum12) *XdrAnon_Asset_AlphaNum12 { return v }
func (u *Asset) AlphaNum4() *XdrAnon_Asset_AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*XdrAnon_Asset_AlphaNum4); ok {
			return v
		} else {
			var zero XdrAnon_Asset_AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Asset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Asset) AlphaNum12() *XdrAnon_Asset_AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*XdrAnon_Asset_AlphaNum12); ok {
			return v
		} else {
			var zero XdrAnon_Asset_AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Asset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Asset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE,ASSET_TYPE_CREDIT_ALPHANUM4,ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *Asset) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *Asset) XdrUnionTagName() string {
	return "Type"
}
func (u *Asset) XdrUnionBody() interface{} {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return u.AlphaNum4()
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return u.AlphaNum12()
	}
	return nil
}
func (u *Asset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	}
	return ""
}
func (v *Asset) XdrPointer() interface{} { return v }
func (v Asset) XdrValue() interface{} { return v }
func (v *Asset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Asset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		XDR_XdrAnon_Asset_AlphaNum4(u.AlphaNum4()).XdrMarshal(x, x.Sprintf("%salphaNum4", name))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		XDR_XdrAnon_Asset_AlphaNum12(u.AlphaNum12()).XdrMarshal(x, x.Sprintf("%salphaNum12", name))
		return
	}
	XdrPanic("invalid Type (%v) in Asset", u.Type)
}
func XDR_Asset(v *Asset) *Asset { return v}
func (v *Price) XdrPointer() interface{} { return v }
func (v Price) XdrValue() interface{} { return v }
func (v *Price) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Price) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Int32(&v.N).XdrMarshal(x, x.Sprintf("%sn", name))
	XDR_Int32(&v.D).XdrMarshal(x, x.Sprintf("%sd", name))
}
func XDR_Price(v *Price) *Price { return v }
func (v *Liabilities) XdrPointer() interface{} { return v }
func (v Liabilities) XdrValue() interface{} { return v }
func (v *Liabilities) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Liabilities) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Int64(&v.Buying).XdrMarshal(x, x.Sprintf("%sbuying", name))
	XDR_Int64(&v.Selling).XdrMarshal(x, x.Sprintf("%sselling", name))
}
func XDR_Liabilities(v *Liabilities) *Liabilities { return v }
var _XdrNames_ThresholdIndexes = map[int32]string{
	int32(THRESHOLD_MASTER_WEIGHT): "THRESHOLD_MASTER_WEIGHT",
	int32(THRESHOLD_LOW): "THRESHOLD_LOW",
	int32(THRESHOLD_MED): "THRESHOLD_MED",
	int32(THRESHOLD_HIGH): "THRESHOLD_HIGH",
}
var _XdrValues_ThresholdIndexes = map[string]int32{
	"THRESHOLD_MASTER_WEIGHT": int32(THRESHOLD_MASTER_WEIGHT),
	"THRESHOLD_LOW": int32(THRESHOLD_LOW),
	"THRESHOLD_MED": int32(THRESHOLD_MED),
	"THRESHOLD_HIGH": int32(THRESHOLD_HIGH),
}
func (ThresholdIndexes) XdrEnumNames() map[int32]string {
	return _XdrNames_ThresholdIndexes
}
func (v ThresholdIndexes) String() string {
	if s, ok := _XdrNames_ThresholdIndexes[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ThresholdIndexes#%d", v)
}
func (v *ThresholdIndexes) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ThresholdIndexes[stok]; ok {
			*v = ThresholdIndexes(val)
			return nil
		} else if stok == "ThresholdIndexes" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ThresholdIndexes.", stok))
	}
}
func (v ThresholdIndexes) GetU32() uint32 { return uint32(v) }
func (v *ThresholdIndexes) SetU32(n uint32) { *v = ThresholdIndexes(n) }
func (v *ThresholdIndexes) XdrPointer() interface{} { return v }
func (v ThresholdIndexes) XdrValue() interface{} { return v }
func (v *ThresholdIndexes) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_ThresholdIndexes(v *ThresholdIndexes) *ThresholdIndexes { return v }
var _XdrNames_LedgerEntryType = map[int32]string{
	int32(ACCOUNT): "ACCOUNT",
	int32(TRUSTLINE): "TRUSTLINE",
	int32(OFFER): "OFFER",
	int32(DATA): "DATA",
}
var _XdrValues_LedgerEntryType = map[string]int32{
	"ACCOUNT": int32(ACCOUNT),
	"TRUSTLINE": int32(TRUSTLINE),
	"OFFER": int32(OFFER),
	"DATA": int32(DATA),
}
func (LedgerEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryType
}
func (v LedgerEntryType) String() string {
	if s, ok := _XdrNames_LedgerEntryType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryType#%d", v)
}
func (v *LedgerEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryType[stok]; ok {
			*v = LedgerEntryType(val)
			return nil
		} else if stok == "LedgerEntryType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryType.", stok))
	}
}
func (v LedgerEntryType) GetU32() uint32 { return uint32(v) }
func (v *LedgerEntryType) SetU32(n uint32) { *v = LedgerEntryType(n) }
func (v *LedgerEntryType) XdrPointer() interface{} { return v }
func (v LedgerEntryType) XdrValue() interface{} { return v }
func (v *LedgerEntryType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_LedgerEntryType(v *LedgerEntryType) *LedgerEntryType { return v }
func (v *Signer) XdrPointer() interface{} { return v }
func (v Signer) XdrValue() interface{} { return v }
func (v *Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Signer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignerKey(&v.Key).XdrMarshal(x, x.Sprintf("%skey", name))
	XDR_Uint32(&v.Weight).XdrMarshal(x, x.Sprintf("%sweight", name))
}
func XDR_Signer(v *Signer) *Signer { return v }
var _XdrNames_AccountFlags = map[int32]string{
	int32(AUTH_REQUIRED_FLAG): "AUTH_REQUIRED_FLAG",
	int32(AUTH_REVOCABLE_FLAG): "AUTH_REVOCABLE_FLAG",
	int32(AUTH_IMMUTABLE_FLAG): "AUTH_IMMUTABLE_FLAG",
}
var _XdrValues_AccountFlags = map[string]int32{
	"AUTH_REQUIRED_FLAG": int32(AUTH_REQUIRED_FLAG),
	"AUTH_REVOCABLE_FLAG": int32(AUTH_REVOCABLE_FLAG),
	"AUTH_IMMUTABLE_FLAG": int32(AUTH_IMMUTABLE_FLAG),
}
func (AccountFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountFlags
}
func (v AccountFlags) String() string {
	if s, ok := _XdrNames_AccountFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountFlags#%d", v)
}
func (v *AccountFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountFlags[stok]; ok {
			*v = AccountFlags(val)
			return nil
		} else if stok == "AccountFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountFlags.", stok))
	}
}
func (v AccountFlags) GetU32() uint32 { return uint32(v) }
func (v *AccountFlags) SetU32(n uint32) { *v = AccountFlags(n) }
func (v *AccountFlags) XdrPointer() interface{} { return v }
func (v AccountFlags) XdrValue() interface{} { return v }
func (v *AccountFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_AccountFlags(v *AccountFlags) *AccountFlags { return v }
var _XdrComments_AccountFlags = map[int32]string {
	int32(AUTH_REQUIRED_FLAG): "Flags set on issuer accounts TrustLines are created with authorized set to \"false\" requiring the issuer to set it for each TrustLine",
	int32(AUTH_REVOCABLE_FLAG): "If set, the authorized flag in TrustLines can be cleared otherwise, authorization cannot be revoked",
	int32(AUTH_IMMUTABLE_FLAG): "Once set, causes all AUTH_* flags to be read-only",
}
func (e AccountFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_AccountFlags
}
func (v *AccountFlags) XdrInitialize() {
	switch AccountFlags(0) {
	case AUTH_REQUIRED_FLAG, AUTH_REVOCABLE_FLAG, AUTH_IMMUTABLE_FLAG:
	default:
		if *v == AccountFlags(0) { *v = AUTH_REQUIRED_FLAG }
	}
}
func (u XdrAnon_AccountEntry_Ext_V1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntry_Ext_V1_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_AccountEntry_Ext_V1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntry_Ext_V1_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_AccountEntry_Ext_V1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_AccountEntry_Ext_V1_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_AccountEntry_Ext_V1_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_AccountEntry_Ext_V1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntry_Ext_V1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntry_Ext_V1_Ext", u.V)
}
func XDR_XdrAnon_AccountEntry_Ext_V1_Ext(v *XdrAnon_AccountEntry_Ext_V1_Ext) *XdrAnon_AccountEntry_Ext_V1_Ext { return v}
func (v *XdrAnon_AccountEntry_Ext_V1) XdrPointer() interface{} { return v }
func (v XdrAnon_AccountEntry_Ext_V1) XdrValue() interface{} { return v }
func (v *XdrAnon_AccountEntry_Ext_V1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_AccountEntry_Ext_V1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Liabilities(&v.Liabilities).XdrMarshal(x, x.Sprintf("%sliabilities", name))
	XDR_XdrAnon_AccountEntry_Ext_V1_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_XdrAnon_AccountEntry_Ext_V1(v *XdrAnon_AccountEntry_Ext_V1) *XdrAnon_AccountEntry_Ext_V1 { return v }
func (u *XdrAnon_AccountEntry_Ext) V1() *XdrAnon_AccountEntry_Ext_V1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*XdrAnon_AccountEntry_Ext_V1); ok {
			return v
		} else {
			var zero XdrAnon_AccountEntry_Ext_V1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AccountEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_AccountEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0,1:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	case 1:
		return u.V1()
	}
	return nil
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}
func (v *XdrAnon_AccountEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_AccountEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_AccountEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		XDR_XdrAnon_AccountEntry_Ext_V1(u.V1()).XdrMarshal(x, x.Sprintf("%sv1", name))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntry_Ext", u.V)
}
func XDR_XdrAnon_AccountEntry_Ext(v *XdrAnon_AccountEntry_Ext) *XdrAnon_AccountEntry_Ext { return v}
type _XdrPtr_AccountID struct {
	p **AccountID
}
type _ptrflag_AccountID _XdrPtr_AccountID
func (v _ptrflag_AccountID) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_AccountID) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("AccountID flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_AccountID) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_AccountID) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(AccountID)
		}
	default:
		XdrPanic("*AccountID present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_AccountID) XdrPointer() interface{} { return nil }
func (v _ptrflag_AccountID) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_AccountID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_AccountID) XdrBound() uint32 { return 1 }
func (v _XdrPtr_AccountID) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_AccountID) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(AccountID)
	}
}
func (v _XdrPtr_AccountID) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_AccountID(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_AccountID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_AccountID) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_AccountID(v))
	v.XdrMarshalValue(x, name)
}
func (v _XdrPtr_AccountID) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_AccountID) XdrValue() interface{} { return *v.p }
type _XdrVec_20_Signer []Signer
func (_XdrVec_20_Signer) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_Signer) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_Signer length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_Signer length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_Signer) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_Signer) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Signer, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_Signer) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Signer(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_Signer) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 20 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_20_Signer) XdrPointer() interface{} { return (*[]Signer)(v) }
func (v _XdrVec_20_Signer) XdrValue() interface{} { return ([]Signer)(v) }
func (v *_XdrVec_20_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntry) XdrPointer() interface{} { return v }
func (v AccountEntry) XdrValue() interface{} { return v }
func (v *AccountEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.AccountID).XdrMarshal(x, x.Sprintf("%saccountID", name))
	XDR_Int64(&v.Balance).XdrMarshal(x, x.Sprintf("%sbalance", name))
	XDR_SequenceNumber(&v.SeqNum).XdrMarshal(x, x.Sprintf("%sseqNum", name))
	XDR_Uint32(&v.NumSubEntries).XdrMarshal(x, x.Sprintf("%snumSubEntries", name))
	x.Marshal(x.Sprintf("%sinflationDest", name), _XdrPtr_AccountID{&v.InflationDest})
	XDR_Uint32(&v.Flags).XdrMarshal(x, x.Sprintf("%sflags", name))
	XDR_String32(&v.HomeDomain).XdrMarshal(x, x.Sprintf("%shomeDomain", name))
	XDR_Thresholds(&v.Thresholds).XdrMarshal(x, x.Sprintf("%sthresholds", name))
	x.Marshal(x.Sprintf("%ssigners", name), (*_XdrVec_20_Signer)(&v.Signers))
	XDR_XdrAnon_AccountEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_AccountEntry(v *AccountEntry) *AccountEntry { return v }
var _XdrNames_TrustLineFlags = map[int32]string{
	int32(AUTHORIZED_FLAG): "AUTHORIZED_FLAG",
}
var _XdrValues_TrustLineFlags = map[string]int32{
	"AUTHORIZED_FLAG": int32(AUTHORIZED_FLAG),
}
func (TrustLineFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_TrustLineFlags
}
func (v TrustLineFlags) String() string {
	if s, ok := _XdrNames_TrustLineFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TrustLineFlags#%d", v)
}
func (v *TrustLineFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TrustLineFlags[stok]; ok {
			*v = TrustLineFlags(val)
			return nil
		} else if stok == "TrustLineFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TrustLineFlags.", stok))
	}
}
func (v TrustLineFlags) GetU32() uint32 { return uint32(v) }
func (v *TrustLineFlags) SetU32(n uint32) { *v = TrustLineFlags(n) }
func (v *TrustLineFlags) XdrPointer() interface{} { return v }
func (v TrustLineFlags) XdrValue() interface{} { return v }
func (v *TrustLineFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_TrustLineFlags(v *TrustLineFlags) *TrustLineFlags { return v }
var _XdrComments_TrustLineFlags = map[int32]string {
	int32(AUTHORIZED_FLAG): "issuer has authorized account to perform transactions with its credit",
}
func (e TrustLineFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_TrustLineFlags
}
func (v *TrustLineFlags) XdrInitialize() {
	switch TrustLineFlags(0) {
	case AUTHORIZED_FLAG:
	default:
		if *v == TrustLineFlags(0) { *v = AUTHORIZED_FLAG }
	}
}
func (u XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntry_Ext_V1_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntry_Ext_V1_Ext(v *XdrAnon_TrustLineEntry_Ext_V1_Ext) *XdrAnon_TrustLineEntry_Ext_V1_Ext { return v}
func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrPointer() interface{} { return v }
func (v XdrAnon_TrustLineEntry_Ext_V1) XdrValue() interface{} { return v }
func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Liabilities(&v.Liabilities).XdrMarshal(x, x.Sprintf("%sliabilities", name))
	XDR_XdrAnon_TrustLineEntry_Ext_V1_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_XdrAnon_TrustLineEntry_Ext_V1(v *XdrAnon_TrustLineEntry_Ext_V1) *XdrAnon_TrustLineEntry_Ext_V1 { return v }
func (u *XdrAnon_TrustLineEntry_Ext) V1() *XdrAnon_TrustLineEntry_Ext_V1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*XdrAnon_TrustLineEntry_Ext_V1); ok {
			return v
		} else {
			var zero XdrAnon_TrustLineEntry_Ext_V1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TrustLineEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_TrustLineEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0,1:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	case 1:
		return u.V1()
	}
	return nil
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}
func (v *XdrAnon_TrustLineEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_TrustLineEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TrustLineEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		XDR_XdrAnon_TrustLineEntry_Ext_V1(u.V1()).XdrMarshal(x, x.Sprintf("%sv1", name))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntry_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntry_Ext(v *XdrAnon_TrustLineEntry_Ext) *XdrAnon_TrustLineEntry_Ext { return v}
func (v *TrustLineEntry) XdrPointer() interface{} { return v }
func (v TrustLineEntry) XdrValue() interface{} { return v }
func (v *TrustLineEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrustLineEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.AccountID).XdrMarshal(x, x.Sprintf("%saccountID", name))
	XDR_Asset(&v.Asset).XdrMarshal(x, x.Sprintf("%sasset", name))
	XDR_Int64(&v.Balance).XdrMarshal(x, x.Sprintf("%sbalance", name))
	XDR_Int64(&v.Limit).XdrMarshal(x, x.Sprintf("%slimit", name))
	XDR_Uint32(&v.Flags).XdrMarshal(x, x.Sprintf("%sflags", name))
	XDR_XdrAnon_TrustLineEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_TrustLineEntry(v *TrustLineEntry) *TrustLineEntry { return v }
var _XdrNames_OfferEntryFlags = map[int32]string{
	int32(PASSIVE_FLAG): "PASSIVE_FLAG",
}
var _XdrValues_OfferEntryFlags = map[string]int32{
	"PASSIVE_FLAG": int32(PASSIVE_FLAG),
}
func (OfferEntryFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_OfferEntryFlags
}
func (v OfferEntryFlags) String() string {
	if s, ok := _XdrNames_OfferEntryFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OfferEntryFlags#%d", v)
}
func (v *OfferEntryFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OfferEntryFlags[stok]; ok {
			*v = OfferEntryFlags(val)
			return nil
		} else if stok == "OfferEntryFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OfferEntryFlags.", stok))
	}
}
func (v OfferEntryFlags) GetU32() uint32 { return uint32(v) }
func (v *OfferEntryFlags) SetU32(n uint32) { *v = OfferEntryFlags(n) }
func (v *OfferEntryFlags) XdrPointer() interface{} { return v }
func (v OfferEntryFlags) XdrValue() interface{} { return v }
func (v *OfferEntryFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_OfferEntryFlags(v *OfferEntryFlags) *OfferEntryFlags { return v }
var _XdrComments_OfferEntryFlags = map[int32]string {
	int32(PASSIVE_FLAG): "issuer has authorized account to perform transactions with its credit",
}
func (e OfferEntryFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_OfferEntryFlags
}
func (v *OfferEntryFlags) XdrInitialize() {
	switch OfferEntryFlags(0) {
	case PASSIVE_FLAG:
	default:
		if *v == OfferEntryFlags(0) { *v = PASSIVE_FLAG }
	}
}
func (u XdrAnon_OfferEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_OfferEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_OfferEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_OfferEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_OfferEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_OfferEntry_Ext", u.V)
}
func XDR_XdrAnon_OfferEntry_Ext(v *XdrAnon_OfferEntry_Ext) *XdrAnon_OfferEntry_Ext { return v}
func (v *OfferEntry) XdrPointer() interface{} { return v }
func (v OfferEntry) XdrValue() interface{} { return v }
func (v *OfferEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OfferEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.SellerID).XdrMarshal(x, x.Sprintf("%ssellerID", name))
	XDR_Int64(&v.OfferID).XdrMarshal(x, x.Sprintf("%sofferID", name))
	XDR_Asset(&v.Selling).XdrMarshal(x, x.Sprintf("%sselling", name))
	XDR_Asset(&v.Buying).XdrMarshal(x, x.Sprintf("%sbuying", name))
	XDR_Int64(&v.Amount).XdrMarshal(x, x.Sprintf("%samount", name))
	XDR_Price(&v.Price).XdrMarshal(x, x.Sprintf("%sprice", name))
	XDR_Uint32(&v.Flags).XdrMarshal(x, x.Sprintf("%sflags", name))
	XDR_XdrAnon_OfferEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_OfferEntry(v *OfferEntry) *OfferEntry { return v }
func (u XdrAnon_DataEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_DataEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_DataEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_DataEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_DataEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_DataEntry_Ext", u.V)
}
func XDR_XdrAnon_DataEntry_Ext(v *XdrAnon_DataEntry_Ext) *XdrAnon_DataEntry_Ext { return v}
func (v *DataEntry) XdrPointer() interface{} { return v }
func (v DataEntry) XdrValue() interface{} { return v }
func (v *DataEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DataEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.AccountID).XdrMarshal(x, x.Sprintf("%saccountID", name))
	XDR_String64(&v.DataName).XdrMarshal(x, x.Sprintf("%sdataName", name))
	XDR_DataValue(&v.DataValue).XdrMarshal(x, x.Sprintf("%sdataValue", name))
	XDR_XdrAnon_DataEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_DataEntry(v *DataEntry) *DataEntry { return v }
func (u *XdrAnon_LedgerEntry_Data) Account() *AccountEntry {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*AccountEntry); ok {
			return v
		} else {
			var zero AccountEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) TrustLine() *TrustLineEntry {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*TrustLineEntry); ok {
			return v
		} else {
			var zero TrustLineEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) Offer() *OfferEntry {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) Data() *DataEntry {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*DataEntry); ok {
			return v
		} else {
			var zero DataEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_LedgerEntry_Data) XdrValid() bool {
	switch u.Type {
	case ACCOUNT,TRUSTLINE,OFFER,DATA:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionBody() interface{} {
	switch u.Type {
	case ACCOUNT:
		return u.Account()
	case TRUSTLINE:
		return u.TrustLine()
	case OFFER:
		return u.Offer()
	case DATA:
		return u.Data()
	}
	return nil
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	}
	return ""
}
func (v *XdrAnon_LedgerEntry_Data) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerEntry_Data) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerEntry_Data) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntry_Data) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ACCOUNT:
		XDR_AccountEntry(u.Account()).XdrMarshal(x, x.Sprintf("%saccount", name))
		return
	case TRUSTLINE:
		XDR_TrustLineEntry(u.TrustLine()).XdrMarshal(x, x.Sprintf("%strustLine", name))
		return
	case OFFER:
		XDR_OfferEntry(u.Offer()).XdrMarshal(x, x.Sprintf("%soffer", name))
		return
	case DATA:
		XDR_DataEntry(u.Data()).XdrMarshal(x, x.Sprintf("%sdata", name))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_LedgerEntry_Data", u.Type)
}
func XDR_XdrAnon_LedgerEntry_Data(v *XdrAnon_LedgerEntry_Data) *XdrAnon_LedgerEntry_Data { return v}
func (u XdrAnon_LedgerEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_LedgerEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerEntry_Ext", u.V)
}
func XDR_XdrAnon_LedgerEntry_Ext(v *XdrAnon_LedgerEntry_Ext) *XdrAnon_LedgerEntry_Ext { return v}
func (v *LedgerEntry) XdrPointer() interface{} { return v }
func (v LedgerEntry) XdrValue() interface{} { return v }
func (v *LedgerEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.LastModifiedLedgerSeq).XdrMarshal(x, x.Sprintf("%slastModifiedLedgerSeq", name))
	XDR_XdrAnon_LedgerEntry_Data(&v.Data).XdrMarshal(x, x.Sprintf("%sdata", name))
	XDR_XdrAnon_LedgerEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_LedgerEntry(v *LedgerEntry) *LedgerEntry { return v }
var _XdrNames_EnvelopeType = map[int32]string{
	int32(ENVELOPE_TYPE_SCP): "ENVELOPE_TYPE_SCP",
	int32(ENVELOPE_TYPE_TX): "ENVELOPE_TYPE_TX",
	int32(ENVELOPE_TYPE_AUTH): "ENVELOPE_TYPE_AUTH",
	int32(ENVELOPE_TYPE_SCPVALUE): "ENVELOPE_TYPE_SCPVALUE",
}
var _XdrValues_EnvelopeType = map[string]int32{
	"ENVELOPE_TYPE_SCP": int32(ENVELOPE_TYPE_SCP),
	"ENVELOPE_TYPE_TX": int32(ENVELOPE_TYPE_TX),
	"ENVELOPE_TYPE_AUTH": int32(ENVELOPE_TYPE_AUTH),
	"ENVELOPE_TYPE_SCPVALUE": int32(ENVELOPE_TYPE_SCPVALUE),
}
func (EnvelopeType) XdrEnumNames() map[int32]string {
	return _XdrNames_EnvelopeType
}
func (v EnvelopeType) String() string {
	if s, ok := _XdrNames_EnvelopeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("EnvelopeType#%d", v)
}
func (v *EnvelopeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_EnvelopeType[stok]; ok {
			*v = EnvelopeType(val)
			return nil
		} else if stok == "EnvelopeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid EnvelopeType.", stok))
	}
}
func (v EnvelopeType) GetU32() uint32 { return uint32(v) }
func (v *EnvelopeType) SetU32(n uint32) { *v = EnvelopeType(n) }
func (v *EnvelopeType) XdrPointer() interface{} { return v }
func (v EnvelopeType) XdrValue() interface{} { return v }
func (v *EnvelopeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_EnvelopeType(v *EnvelopeType) *EnvelopeType { return v }
func (v *EnvelopeType) XdrInitialize() {
	switch EnvelopeType(0) {
	case ENVELOPE_TYPE_SCP, ENVELOPE_TYPE_TX, ENVELOPE_TYPE_AUTH, ENVELOPE_TYPE_SCPVALUE:
	default:
		if *v == EnvelopeType(0) { *v = ENVELOPE_TYPE_SCP }
	}
}
type _XdrTypedef_UpgradeType struct {
	p *UpgradeType
}
func (v _XdrTypedef_UpgradeType) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_UpgradeType) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_UpgradeType) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_UpgradeType(string, *UpgradeType)
	}); ok {
		xs.Marshal_UpgradeType(name, v.p)
	} else {
		x.Marshal(name, XdrVecOpaque{v.p, 128})
	}
}
func XDR_UpgradeType(v *UpgradeType) _XdrTypedef_UpgradeType {
	return _XdrTypedef_UpgradeType{ v }
}
var _XdrNames_StellarValueType = map[int32]string{
	int32(STELLAR_VALUE_BASIC): "STELLAR_VALUE_BASIC",
	int32(STELLAR_VALUE_SIGNED): "STELLAR_VALUE_SIGNED",
}
var _XdrValues_StellarValueType = map[string]int32{
	"STELLAR_VALUE_BASIC": int32(STELLAR_VALUE_BASIC),
	"STELLAR_VALUE_SIGNED": int32(STELLAR_VALUE_SIGNED),
}
func (StellarValueType) XdrEnumNames() map[int32]string {
	return _XdrNames_StellarValueType
}
func (v StellarValueType) String() string {
	if s, ok := _XdrNames_StellarValueType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("StellarValueType#%d", v)
}
func (v *StellarValueType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_StellarValueType[stok]; ok {
			*v = StellarValueType(val)
			return nil
		} else if stok == "StellarValueType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid StellarValueType.", stok))
	}
}
func (v StellarValueType) GetU32() uint32 { return uint32(v) }
func (v *StellarValueType) SetU32(n uint32) { *v = StellarValueType(n) }
func (v *StellarValueType) XdrPointer() interface{} { return v }
func (v StellarValueType) XdrValue() interface{} { return v }
func (v *StellarValueType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_StellarValueType(v *StellarValueType) *StellarValueType { return v }
func (v *LedgerCloseValueSignature) XdrPointer() interface{} { return v }
func (v LedgerCloseValueSignature) XdrValue() interface{} { return v }
func (v *LedgerCloseValueSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseValueSignature) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_NodeID(&v.NodeID).XdrMarshal(x, x.Sprintf("%snodeID", name))
	XDR_Signature(&v.Signature).XdrMarshal(x, x.Sprintf("%ssignature", name))
}
func XDR_LedgerCloseValueSignature(v *LedgerCloseValueSignature) *LedgerCloseValueSignature { return v }
func (u *XdrAnon_StellarValue_Ext) LcValueSignature() *LedgerCloseValueSignature {
	switch u.V {
	case STELLAR_VALUE_SIGNED:
		if v, ok := u._u.(*LedgerCloseValueSignature); ok {
			return v
		} else {
			var zero LedgerCloseValueSignature
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_StellarValue_Ext.LcValueSignature accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_StellarValue_Ext) XdrValid() bool {
	switch u.V {
	case STELLAR_VALUE_BASIC,STELLAR_VALUE_SIGNED:
		return true
	}
	return false
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return nil
	case STELLAR_VALUE_SIGNED:
		return u.LcValueSignature()
	}
	return nil
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionBodyName() string {
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return ""
	case STELLAR_VALUE_SIGNED:
		return "LcValueSignature"
	}
	return ""
}
func (v *XdrAnon_StellarValue_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_StellarValue_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_StellarValue_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_StellarValue_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_StellarValueType(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return
	case STELLAR_VALUE_SIGNED:
		XDR_LedgerCloseValueSignature(u.LcValueSignature()).XdrMarshal(x, x.Sprintf("%slcValueSignature", name))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_StellarValue_Ext", u.V)
}
func XDR_XdrAnon_StellarValue_Ext(v *XdrAnon_StellarValue_Ext) *XdrAnon_StellarValue_Ext { return v}
type _XdrVec_6_UpgradeType []UpgradeType
func (_XdrVec_6_UpgradeType) XdrBound() uint32 {
	const bound uint32 = 6 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_6_UpgradeType) XdrCheckLen(length uint32) {
	if length > uint32(6) {
		XdrPanic("_XdrVec_6_UpgradeType length %d exceeds bound 6", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_6_UpgradeType length %d exceeds max int", length)
	}
}
func (v _XdrVec_6_UpgradeType) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_6_UpgradeType) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(6); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]UpgradeType, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_6_UpgradeType) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_UpgradeType(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_6_UpgradeType) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 6 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_6_UpgradeType) XdrPointer() interface{} { return (*[]UpgradeType)(v) }
func (v _XdrVec_6_UpgradeType) XdrValue() interface{} { return ([]UpgradeType)(v) }
func (v *_XdrVec_6_UpgradeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *StellarValue) XdrPointer() interface{} { return v }
func (v StellarValue) XdrValue() interface{} { return v }
func (v *StellarValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *StellarValue) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(&v.TxSetHash).XdrMarshal(x, x.Sprintf("%stxSetHash", name))
	XDR_TimePoint(&v.CloseTime).XdrMarshal(x, x.Sprintf("%scloseTime", name))
	x.Marshal(x.Sprintf("%supgrades", name), (*_XdrVec_6_UpgradeType)(&v.Upgrades))
	XDR_XdrAnon_StellarValue_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_StellarValue(v *StellarValue) *StellarValue { return v }
func (u XdrAnon_LedgerHeader_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_LedgerHeader_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerHeader_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerHeader_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeader_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeader_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeader_Ext(v *XdrAnon_LedgerHeader_Ext) *XdrAnon_LedgerHeader_Ext { return v}
type _XdrArray_4_Hash [4]Hash
func (_XdrArray_4_Hash) XdrArraySize() uint32 {
	const bound uint32 = 4 // Force error if not const or doesn't fit
	return bound
}
func (v *_XdrArray_4_Hash) XdrRecurse(x XDR, name string) {
	for i := 0; i < len(*v); i++ {
		XDR_Hash(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
}
func (v *_XdrArray_4_Hash) XdrPointer() interface{} { return (*[4]Hash)(v) }
func (v *_XdrArray_4_Hash) XdrValue() interface{} { return v[:] }
func (v *_XdrArray_4_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeader) XdrPointer() interface{} { return v }
func (v LedgerHeader) XdrValue() interface{} { return v }
func (v *LedgerHeader) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeader) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.LedgerVersion).XdrMarshal(x, x.Sprintf("%sledgerVersion", name))
	XDR_Hash(&v.PreviousLedgerHash).XdrMarshal(x, x.Sprintf("%spreviousLedgerHash", name))
	XDR_StellarValue(&v.ScpValue).XdrMarshal(x, x.Sprintf("%sscpValue", name))
	XDR_Hash(&v.TxSetResultHash).XdrMarshal(x, x.Sprintf("%stxSetResultHash", name))
	XDR_Hash(&v.BucketListHash).XdrMarshal(x, x.Sprintf("%sbucketListHash", name))
	XDR_Uint32(&v.LedgerSeq).XdrMarshal(x, x.Sprintf("%sledgerSeq", name))
	XDR_Int64(&v.TotalCoins).XdrMarshal(x, x.Sprintf("%stotalCoins", name))
	XDR_Int64(&v.FeePool).XdrMarshal(x, x.Sprintf("%sfeePool", name))
	XDR_Uint32(&v.InflationSeq).XdrMarshal(x, x.Sprintf("%sinflationSeq", name))
	XDR_Uint64(&v.IdPool).XdrMarshal(x, x.Sprintf("%sidPool", name))
	XDR_Uint32(&v.BaseFee).XdrMarshal(x, x.Sprintf("%sbaseFee", name))
	XDR_Uint32(&v.BaseReserve).XdrMarshal(x, x.Sprintf("%sbaseReserve", name))
	XDR_Uint32(&v.MaxTxSetSize).XdrMarshal(x, x.Sprintf("%smaxTxSetSize", name))
	x.Marshal(x.Sprintf("%sskipList", name), (*_XdrArray_4_Hash)(&v.SkipList))
	XDR_XdrAnon_LedgerHeader_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_LedgerHeader(v *LedgerHeader) *LedgerHeader { return v }
var _XdrNames_LedgerUpgradeType = map[int32]string{
	int32(LEDGER_UPGRADE_VERSION): "LEDGER_UPGRADE_VERSION",
	int32(LEDGER_UPGRADE_BASE_FEE): "LEDGER_UPGRADE_BASE_FEE",
	int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE): "LEDGER_UPGRADE_MAX_TX_SET_SIZE",
	int32(LEDGER_UPGRADE_BASE_RESERVE): "LEDGER_UPGRADE_BASE_RESERVE",
}
var _XdrValues_LedgerUpgradeType = map[string]int32{
	"LEDGER_UPGRADE_VERSION": int32(LEDGER_UPGRADE_VERSION),
	"LEDGER_UPGRADE_BASE_FEE": int32(LEDGER_UPGRADE_BASE_FEE),
	"LEDGER_UPGRADE_MAX_TX_SET_SIZE": int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE),
	"LEDGER_UPGRADE_BASE_RESERVE": int32(LEDGER_UPGRADE_BASE_RESERVE),
}
func (LedgerUpgradeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerUpgradeType
}
func (v LedgerUpgradeType) String() string {
	if s, ok := _XdrNames_LedgerUpgradeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerUpgradeType#%d", v)
}
func (v *LedgerUpgradeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerUpgradeType[stok]; ok {
			*v = LedgerUpgradeType(val)
			return nil
		} else if stok == "LedgerUpgradeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerUpgradeType.", stok))
	}
}
func (v LedgerUpgradeType) GetU32() uint32 { return uint32(v) }
func (v *LedgerUpgradeType) SetU32(n uint32) { *v = LedgerUpgradeType(n) }
func (v *LedgerUpgradeType) XdrPointer() interface{} { return v }
func (v LedgerUpgradeType) XdrValue() interface{} { return v }
func (v *LedgerUpgradeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_LedgerUpgradeType(v *LedgerUpgradeType) *LedgerUpgradeType { return v }
func (v *LedgerUpgradeType) XdrInitialize() {
	switch LedgerUpgradeType(0) {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE:
	default:
		if *v == LedgerUpgradeType(0) { *v = LEDGER_UPGRADE_VERSION }
	}
}
// update ledgerVersion
func (u *LedgerUpgrade) NewLedgerVersion() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewLedgerVersion accessed when Type == %v", u.Type)
		return nil
	}
}
// update baseFee
func (u *LedgerUpgrade) NewBaseFee() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_FEE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewBaseFee accessed when Type == %v", u.Type)
		return nil
	}
}
// update maxTxSetSize
func (u *LedgerUpgrade) NewMaxTxSetSize() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewMaxTxSetSize accessed when Type == %v", u.Type)
		return nil
	}
}
// update baseReserve
func (u *LedgerUpgrade) NewBaseReserve() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_RESERVE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewBaseReserve accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerUpgrade) XdrValid() bool {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION,LEDGER_UPGRADE_BASE_FEE,LEDGER_UPGRADE_MAX_TX_SET_SIZE,LEDGER_UPGRADE_BASE_RESERVE:
		return true
	}
	return false
}
func (u *LedgerUpgrade) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *LedgerUpgrade) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerUpgrade) XdrUnionBody() interface{} {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return u.NewLedgerVersion()
	case LEDGER_UPGRADE_BASE_FEE:
		return u.NewBaseFee()
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return u.NewMaxTxSetSize()
	case LEDGER_UPGRADE_BASE_RESERVE:
		return u.NewBaseReserve()
	}
	return nil
}
func (u *LedgerUpgrade) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return "NewLedgerVersion"
	case LEDGER_UPGRADE_BASE_FEE:
		return "NewBaseFee"
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return "NewMaxTxSetSize"
	case LEDGER_UPGRADE_BASE_RESERVE:
		return "NewBaseReserve"
	}
	return ""
}
func (v *LedgerUpgrade) XdrPointer() interface{} { return v }
func (v LedgerUpgrade) XdrValue() interface{} { return v }
func (v *LedgerUpgrade) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerUpgrade) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerUpgradeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		XDR_Uint32(u.NewLedgerVersion()).XdrMarshal(x, x.Sprintf("%snewLedgerVersion", name))
		return
	case LEDGER_UPGRADE_BASE_FEE:
		XDR_Uint32(u.NewBaseFee()).XdrMarshal(x, x.Sprintf("%snewBaseFee", name))
		return
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		XDR_Uint32(u.NewMaxTxSetSize()).XdrMarshal(x, x.Sprintf("%snewMaxTxSetSize", name))
		return
	case LEDGER_UPGRADE_BASE_RESERVE:
		XDR_Uint32(u.NewBaseReserve()).XdrMarshal(x, x.Sprintf("%snewBaseReserve", name))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerUpgrade", u.Type)
}
func (v *LedgerUpgrade) XdrInitialize() {
	var zero LedgerUpgradeType
	switch zero {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE:
	default:
		if v.Type == zero { v.Type = LEDGER_UPGRADE_VERSION }
	}
}
func XDR_LedgerUpgrade(v *LedgerUpgrade) *LedgerUpgrade { return v}
func (v *XdrAnon_LedgerKey_Account) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerKey_Account) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerKey_Account) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Account) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.AccountID).XdrMarshal(x, x.Sprintf("%saccountID", name))
}
func XDR_XdrAnon_LedgerKey_Account(v *XdrAnon_LedgerKey_Account) *XdrAnon_LedgerKey_Account { return v }
func (v *XdrAnon_LedgerKey_TrustLine) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerKey_TrustLine) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerKey_TrustLine) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_TrustLine) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.AccountID).XdrMarshal(x, x.Sprintf("%saccountID", name))
	XDR_Asset(&v.Asset).XdrMarshal(x, x.Sprintf("%sasset", name))
}
func XDR_XdrAnon_LedgerKey_TrustLine(v *XdrAnon_LedgerKey_TrustLine) *XdrAnon_LedgerKey_TrustLine { return v }
func (v *XdrAnon_LedgerKey_Offer) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerKey_Offer) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerKey_Offer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Offer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.SellerID).XdrMarshal(x, x.Sprintf("%ssellerID", name))
	XDR_Int64(&v.OfferID).XdrMarshal(x, x.Sprintf("%sofferID", name))
}
func XDR_XdrAnon_LedgerKey_Offer(v *XdrAnon_LedgerKey_Offer) *XdrAnon_LedgerKey_Offer { return v }
func (v *XdrAnon_LedgerKey_Data) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerKey_Data) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerKey_Data) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Data) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.AccountID).XdrMarshal(x, x.Sprintf("%saccountID", name))
	XDR_String64(&v.DataName).XdrMarshal(x, x.Sprintf("%sdataName", name))
}
func XDR_XdrAnon_LedgerKey_Data(v *XdrAnon_LedgerKey_Data) *XdrAnon_LedgerKey_Data { return v }
func (u *LedgerKey) Account() *XdrAnon_LedgerKey_Account {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Account); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Account
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) TrustLine() *XdrAnon_LedgerKey_TrustLine {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*XdrAnon_LedgerKey_TrustLine); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_TrustLine
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Offer() *XdrAnon_LedgerKey_Offer {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Offer); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Offer
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Data() *XdrAnon_LedgerKey_Data {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Data); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Data
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerKey) XdrValid() bool {
	switch u.Type {
	case ACCOUNT,TRUSTLINE,OFFER,DATA:
		return true
	}
	return false
}
func (u *LedgerKey) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *LedgerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerKey) XdrUnionBody() interface{} {
	switch u.Type {
	case ACCOUNT:
		return u.Account()
	case TRUSTLINE:
		return u.TrustLine()
	case OFFER:
		return u.Offer()
	case DATA:
		return u.Data()
	}
	return nil
}
func (u *LedgerKey) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	}
	return ""
}
func (v *LedgerKey) XdrPointer() interface{} { return v }
func (v LedgerKey) XdrValue() interface{} { return v }
func (v *LedgerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ACCOUNT:
		XDR_XdrAnon_LedgerKey_Account(u.Account()).XdrMarshal(x, x.Sprintf("%saccount", name))
		return
	case TRUSTLINE:
		XDR_XdrAnon_LedgerKey_TrustLine(u.TrustLine()).XdrMarshal(x, x.Sprintf("%strustLine", name))
		return
	case OFFER:
		XDR_XdrAnon_LedgerKey_Offer(u.Offer()).XdrMarshal(x, x.Sprintf("%soffer", name))
		return
	case DATA:
		XDR_XdrAnon_LedgerKey_Data(u.Data()).XdrMarshal(x, x.Sprintf("%sdata", name))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerKey", u.Type)
}
func XDR_LedgerKey(v *LedgerKey) *LedgerKey { return v}
var _XdrNames_BucketEntryType = map[int32]string{
	int32(METAENTRY): "METAENTRY",
	int32(LIVEENTRY): "LIVEENTRY",
	int32(DEADENTRY): "DEADENTRY",
	int32(INITENTRY): "INITENTRY",
}
var _XdrValues_BucketEntryType = map[string]int32{
	"METAENTRY": int32(METAENTRY),
	"LIVEENTRY": int32(LIVEENTRY),
	"DEADENTRY": int32(DEADENTRY),
	"INITENTRY": int32(INITENTRY),
}
func (BucketEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_BucketEntryType
}
func (v BucketEntryType) String() string {
	if s, ok := _XdrNames_BucketEntryType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BucketEntryType#%d", v)
}
func (v *BucketEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BucketEntryType[stok]; ok {
			*v = BucketEntryType(val)
			return nil
		} else if stok == "BucketEntryType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BucketEntryType.", stok))
	}
}
func (v BucketEntryType) GetU32() uint32 { return uint32(v) }
func (v *BucketEntryType) SetU32(n uint32) { *v = BucketEntryType(n) }
func (v *BucketEntryType) XdrPointer() interface{} { return v }
func (v BucketEntryType) XdrValue() interface{} { return v }
func (v *BucketEntryType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_BucketEntryType(v *BucketEntryType) *BucketEntryType { return v }
var _XdrComments_BucketEntryType = map[int32]string {
	int32(METAENTRY): "At-and-after protocol 11: bucket metadata, should come first.",
	int32(LIVEENTRY): "Before protocol 11: created-or-updated;",
	int32(DEADENTRY): "At-and-after protocol 11: only updated.",
	int32(INITENTRY): "At-and-after protocol 11: only created.",
}
func (e BucketEntryType) XdrEnumComments() map[int32]string {
	return _XdrComments_BucketEntryType
}
func (u XdrAnon_BucketMetadata_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_BucketMetadata_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_BucketMetadata_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_BucketMetadata_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_BucketMetadata_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_BucketMetadata_Ext", u.V)
}
func XDR_XdrAnon_BucketMetadata_Ext(v *XdrAnon_BucketMetadata_Ext) *XdrAnon_BucketMetadata_Ext { return v}
func (v *BucketMetadata) XdrPointer() interface{} { return v }
func (v BucketMetadata) XdrValue() interface{} { return v }
func (v *BucketMetadata) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BucketMetadata) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.LedgerVersion).XdrMarshal(x, x.Sprintf("%sledgerVersion", name))
	XDR_XdrAnon_BucketMetadata_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_BucketMetadata(v *BucketMetadata) *BucketMetadata { return v }
func (u *BucketEntry) LiveEntry() *LedgerEntry {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.LiveEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) DeadEntry() *LedgerKey {
	switch u.Type {
	case DEADENTRY:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.DeadEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) MetaEntry() *BucketMetadata {
	switch u.Type {
	case METAENTRY:
		if v, ok := u._u.(*BucketMetadata); ok {
			return v
		} else {
			var zero BucketMetadata
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.MetaEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u BucketEntry) XdrValid() bool {
	switch u.Type {
	case LIVEENTRY, INITENTRY,DEADENTRY,METAENTRY:
		return true
	}
	return false
}
func (u *BucketEntry) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *BucketEntry) XdrUnionTagName() string {
	return "Type"
}
func (u *BucketEntry) XdrUnionBody() interface{} {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		return u.LiveEntry()
	case DEADENTRY:
		return u.DeadEntry()
	case METAENTRY:
		return u.MetaEntry()
	}
	return nil
}
func (u *BucketEntry) XdrUnionBodyName() string {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		return "LiveEntry"
	case DEADENTRY:
		return "DeadEntry"
	case METAENTRY:
		return "MetaEntry"
	}
	return ""
}
func (v *BucketEntry) XdrPointer() interface{} { return v }
func (v BucketEntry) XdrValue() interface{} { return v }
func (v *BucketEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BucketEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BucketEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		XDR_LedgerEntry(u.LiveEntry()).XdrMarshal(x, x.Sprintf("%sliveEntry", name))
		return
	case DEADENTRY:
		XDR_LedgerKey(u.DeadEntry()).XdrMarshal(x, x.Sprintf("%sdeadEntry", name))
		return
	case METAENTRY:
		XDR_BucketMetadata(u.MetaEntry()).XdrMarshal(x, x.Sprintf("%smetaEntry", name))
		return
	}
	XdrPanic("invalid Type (%v) in BucketEntry", u.Type)
}
func XDR_BucketEntry(v *BucketEntry) *BucketEntry { return v}
type _XdrVec_unbounded_TransactionEnvelope []TransactionEnvelope
func (_XdrVec_unbounded_TransactionEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionEnvelope length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionEnvelope) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_TransactionEnvelope(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrPointer() interface{} { return (*[]TransactionEnvelope)(v) }
func (v _XdrVec_unbounded_TransactionEnvelope) XdrValue() interface{} { return ([]TransactionEnvelope)(v) }
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSet) XdrPointer() interface{} { return v }
func (v TransactionSet) XdrValue() interface{} { return v }
func (v *TransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(&v.PreviousLedgerHash).XdrMarshal(x, x.Sprintf("%spreviousLedgerHash", name))
	x.Marshal(x.Sprintf("%stxs", name), (*_XdrVec_unbounded_TransactionEnvelope)(&v.Txs))
}
func XDR_TransactionSet(v *TransactionSet) *TransactionSet { return v }
func (v *TransactionResultPair) XdrPointer() interface{} { return v }
func (v TransactionResultPair) XdrValue() interface{} { return v }
func (v *TransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultPair) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(&v.TransactionHash).XdrMarshal(x, x.Sprintf("%stransactionHash", name))
	XDR_TransactionResult(&v.Result).XdrMarshal(x, x.Sprintf("%sresult", name))
}
func XDR_TransactionResultPair(v *TransactionResultPair) *TransactionResultPair { return v }
type _XdrVec_unbounded_TransactionResultPair []TransactionResultPair
func (_XdrVec_unbounded_TransactionResultPair) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionResultPair) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionResultPair length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionResultPair length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionResultPair) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionResultPair) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultPair, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_TransactionResultPair(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrPointer() interface{} { return (*[]TransactionResultPair)(v) }
func (v _XdrVec_unbounded_TransactionResultPair) XdrValue() interface{} { return ([]TransactionResultPair)(v) }
func (v *_XdrVec_unbounded_TransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultSet) XdrPointer() interface{} { return v }
func (v TransactionResultSet) XdrValue() interface{} { return v }
func (v *TransactionResultSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_TransactionResultPair)(&v.Results))
}
func XDR_TransactionResultSet(v *TransactionResultSet) *TransactionResultSet { return v }
func (u XdrAnon_TransactionHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_TransactionHistoryEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_TransactionHistoryEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionHistoryEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionHistoryEntry_Ext", u.V)
}
func XDR_XdrAnon_TransactionHistoryEntry_Ext(v *XdrAnon_TransactionHistoryEntry_Ext) *XdrAnon_TransactionHistoryEntry_Ext { return v}
func (v *TransactionHistoryEntry) XdrPointer() interface{} { return v }
func (v TransactionHistoryEntry) XdrValue() interface{} { return v }
func (v *TransactionHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.LedgerSeq).XdrMarshal(x, x.Sprintf("%sledgerSeq", name))
	XDR_TransactionSet(&v.TxSet).XdrMarshal(x, x.Sprintf("%stxSet", name))
	XDR_XdrAnon_TransactionHistoryEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_TransactionHistoryEntry(v *TransactionHistoryEntry) *TransactionHistoryEntry { return v }
func (u XdrAnon_TransactionHistoryResultEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_TransactionHistoryResultEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_TransactionHistoryResultEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionHistoryResultEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionHistoryResultEntry_Ext", u.V)
}
func XDR_XdrAnon_TransactionHistoryResultEntry_Ext(v *XdrAnon_TransactionHistoryResultEntry_Ext) *XdrAnon_TransactionHistoryResultEntry_Ext { return v}
func (v *TransactionHistoryResultEntry) XdrPointer() interface{} { return v }
func (v TransactionHistoryResultEntry) XdrValue() interface{} { return v }
func (v *TransactionHistoryResultEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionHistoryResultEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.LedgerSeq).XdrMarshal(x, x.Sprintf("%sledgerSeq", name))
	XDR_TransactionResultSet(&v.TxResultSet).XdrMarshal(x, x.Sprintf("%stxResultSet", name))
	XDR_XdrAnon_TransactionHistoryResultEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_TransactionHistoryResultEntry(v *TransactionHistoryResultEntry) *TransactionHistoryResultEntry { return v }
func (u XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeaderHistoryEntry_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeaderHistoryEntry_Ext(v *XdrAnon_LedgerHeaderHistoryEntry_Ext) *XdrAnon_LedgerHeaderHistoryEntry_Ext { return v}
func (v *LedgerHeaderHistoryEntry) XdrPointer() interface{} { return v }
func (v LedgerHeaderHistoryEntry) XdrValue() interface{} { return v }
func (v *LedgerHeaderHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeaderHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(&v.Hash).XdrMarshal(x, x.Sprintf("%shash", name))
	XDR_LedgerHeader(&v.Header).XdrMarshal(x, x.Sprintf("%sheader", name))
	XDR_XdrAnon_LedgerHeaderHistoryEntry_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_LedgerHeaderHistoryEntry(v *LedgerHeaderHistoryEntry) *LedgerHeaderHistoryEntry { return v }
type _XdrVec_unbounded_SCPEnvelope []SCPEnvelope
func (_XdrVec_unbounded_SCPEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPEnvelope length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPEnvelope) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_SCPEnvelope(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPEnvelope) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_SCPEnvelope) XdrPointer() interface{} { return (*[]SCPEnvelope)(v) }
func (v _XdrVec_unbounded_SCPEnvelope) XdrValue() interface{} { return ([]SCPEnvelope)(v) }
func (v *_XdrVec_unbounded_SCPEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerSCPMessages) XdrPointer() interface{} { return v }
func (v LedgerSCPMessages) XdrValue() interface{} { return v }
func (v *LedgerSCPMessages) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerSCPMessages) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.LedgerSeq).XdrMarshal(x, x.Sprintf("%sledgerSeq", name))
	x.Marshal(x.Sprintf("%smessages", name), (*_XdrVec_unbounded_SCPEnvelope)(&v.Messages))
}
func XDR_LedgerSCPMessages(v *LedgerSCPMessages) *LedgerSCPMessages { return v }
func (v *SCPHistoryEntryV0) XdrPointer() interface{} { return v }
func (v SCPHistoryEntryV0) XdrValue() interface{} { return v }
func (v *SCPHistoryEntryV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPHistoryEntryV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
	XDR_LedgerSCPMessages(&v.LedgerMessages).XdrMarshal(x, x.Sprintf("%sledgerMessages", name))
}
func XDR_SCPHistoryEntryV0(v *SCPHistoryEntryV0) *SCPHistoryEntryV0 { return v }
func (u *SCPHistoryEntry) V0() *SCPHistoryEntryV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*SCPHistoryEntryV0); ok {
			return v
		} else {
			var zero SCPHistoryEntryV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCPHistoryEntry.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u SCPHistoryEntry) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *SCPHistoryEntry) XdrUnionTag() interface{} {
	return &u.V
}
func (u *SCPHistoryEntry) XdrUnionTagName() string {
	return "V"
}
func (u *SCPHistoryEntry) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return u.V0()
	}
	return nil
}
func (u *SCPHistoryEntry) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}
func (v *SCPHistoryEntry) XdrPointer() interface{} { return v }
func (v SCPHistoryEntry) XdrValue() interface{} { return v }
func (v *SCPHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCPHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		XDR_SCPHistoryEntryV0(u.V0()).XdrMarshal(x, x.Sprintf("%sv0", name))
		return
	}
	XdrPanic("invalid V (%v) in SCPHistoryEntry", u.V)
}
func XDR_SCPHistoryEntry(v *SCPHistoryEntry) *SCPHistoryEntry { return v}
var _XdrNames_LedgerEntryChangeType = map[int32]string{
	int32(LEDGER_ENTRY_CREATED): "LEDGER_ENTRY_CREATED",
	int32(LEDGER_ENTRY_UPDATED): "LEDGER_ENTRY_UPDATED",
	int32(LEDGER_ENTRY_REMOVED): "LEDGER_ENTRY_REMOVED",
	int32(LEDGER_ENTRY_STATE): "LEDGER_ENTRY_STATE",
}
var _XdrValues_LedgerEntryChangeType = map[string]int32{
	"LEDGER_ENTRY_CREATED": int32(LEDGER_ENTRY_CREATED),
	"LEDGER_ENTRY_UPDATED": int32(LEDGER_ENTRY_UPDATED),
	"LEDGER_ENTRY_REMOVED": int32(LEDGER_ENTRY_REMOVED),
	"LEDGER_ENTRY_STATE": int32(LEDGER_ENTRY_STATE),
}
func (LedgerEntryChangeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryChangeType
}
func (v LedgerEntryChangeType) String() string {
	if s, ok := _XdrNames_LedgerEntryChangeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryChangeType#%d", v)
}
func (v *LedgerEntryChangeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryChangeType[stok]; ok {
			*v = LedgerEntryChangeType(val)
			return nil
		} else if stok == "LedgerEntryChangeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryChangeType.", stok))
	}
}
func (v LedgerEntryChangeType) GetU32() uint32 { return uint32(v) }
func (v *LedgerEntryChangeType) SetU32(n uint32) { *v = LedgerEntryChangeType(n) }
func (v *LedgerEntryChangeType) XdrPointer() interface{} { return v }
func (v LedgerEntryChangeType) XdrValue() interface{} { return v }
func (v *LedgerEntryChangeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_LedgerEntryChangeType(v *LedgerEntryChangeType) *LedgerEntryChangeType { return v }
var _XdrComments_LedgerEntryChangeType = map[int32]string {
	int32(LEDGER_ENTRY_CREATED): "entry was added to the ledger",
	int32(LEDGER_ENTRY_UPDATED): "entry was modified in the ledger",
	int32(LEDGER_ENTRY_REMOVED): "entry was removed from the ledger",
	int32(LEDGER_ENTRY_STATE): "value of the entry",
}
func (e LedgerEntryChangeType) XdrEnumComments() map[int32]string {
	return _XdrComments_LedgerEntryChangeType
}
func (u *LedgerEntryChange) Created() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Created accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Updated() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_UPDATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Updated accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Removed() *LedgerKey {
	switch u.Type {
	case LEDGER_ENTRY_REMOVED:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Removed accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) State() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_STATE:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.State accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerEntryChange) XdrValid() bool {
	switch u.Type {
	case LEDGER_ENTRY_CREATED,LEDGER_ENTRY_UPDATED,LEDGER_ENTRY_REMOVED,LEDGER_ENTRY_STATE:
		return true
	}
	return false
}
func (u *LedgerEntryChange) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *LedgerEntryChange) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerEntryChange) XdrUnionBody() interface{} {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return u.Created()
	case LEDGER_ENTRY_UPDATED:
		return u.Updated()
	case LEDGER_ENTRY_REMOVED:
		return u.Removed()
	case LEDGER_ENTRY_STATE:
		return u.State()
	}
	return nil
}
func (u *LedgerEntryChange) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return "Created"
	case LEDGER_ENTRY_UPDATED:
		return "Updated"
	case LEDGER_ENTRY_REMOVED:
		return "Removed"
	case LEDGER_ENTRY_STATE:
		return "State"
	}
	return ""
}
func (v *LedgerEntryChange) XdrPointer() interface{} { return v }
func (v LedgerEntryChange) XdrValue() interface{} { return v }
func (v *LedgerEntryChange) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerEntryChange) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChangeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		XDR_LedgerEntry(u.Created()).XdrMarshal(x, x.Sprintf("%screated", name))
		return
	case LEDGER_ENTRY_UPDATED:
		XDR_LedgerEntry(u.Updated()).XdrMarshal(x, x.Sprintf("%supdated", name))
		return
	case LEDGER_ENTRY_REMOVED:
		XDR_LedgerKey(u.Removed()).XdrMarshal(x, x.Sprintf("%sremoved", name))
		return
	case LEDGER_ENTRY_STATE:
		XDR_LedgerEntry(u.State()).XdrMarshal(x, x.Sprintf("%sstate", name))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerEntryChange", u.Type)
}
func XDR_LedgerEntryChange(v *LedgerEntryChange) *LedgerEntryChange { return v}
type _XdrVec_unbounded_LedgerEntryChange []LedgerEntryChange
func (_XdrVec_unbounded_LedgerEntryChange) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_LedgerEntryChange) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_LedgerEntryChange length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_LedgerEntryChange length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_LedgerEntryChange) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_LedgerEntryChange) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerEntryChange, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_LedgerEntryChange(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrPointer() interface{} { return (*[]LedgerEntryChange)(v) }
func (v _XdrVec_unbounded_LedgerEntryChange) XdrValue() interface{} { return ([]LedgerEntryChange)(v) }
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type _XdrTypedef_LedgerEntryChanges struct {
	p *LedgerEntryChanges
}
func (v _XdrTypedef_LedgerEntryChanges) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_LedgerEntryChanges) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_LedgerEntryChanges) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_LedgerEntryChanges(string, *LedgerEntryChanges)
	}); ok {
		xs.Marshal_LedgerEntryChanges(name, v.p)
	} else {
		x.Marshal(name, (*_XdrVec_unbounded_LedgerEntryChange)(v.p))
	}
}
func XDR_LedgerEntryChanges(v *LedgerEntryChanges) _XdrTypedef_LedgerEntryChanges {
	return _XdrTypedef_LedgerEntryChanges{ v }
}
func (v *OperationMeta) XdrPointer() interface{} { return v }
func (v OperationMeta) XdrValue() interface{} { return v }
func (v *OperationMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OperationMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChanges(&v.Changes).XdrMarshal(x, x.Sprintf("%schanges", name))
}
func XDR_OperationMeta(v *OperationMeta) *OperationMeta { return v }
type _XdrVec_unbounded_OperationMeta []OperationMeta
func (_XdrVec_unbounded_OperationMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_OperationMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_OperationMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_OperationMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_OperationMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_OperationMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_OperationMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_OperationMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_OperationMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_OperationMeta) XdrPointer() interface{} { return (*[]OperationMeta)(v) }
func (v _XdrVec_unbounded_OperationMeta) XdrValue() interface{} { return ([]OperationMeta)(v) }
func (v *_XdrVec_unbounded_OperationMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV1) XdrPointer() interface{} { return v }
func (v TransactionMetaV1) XdrValue() interface{} { return v }
func (v *TransactionMetaV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChanges(&v.TxChanges).XdrMarshal(x, x.Sprintf("%stxChanges", name))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
}
func XDR_TransactionMetaV1(v *TransactionMetaV1) *TransactionMetaV1 { return v }
func (v *TransactionMetaV2) XdrPointer() interface{} { return v }
func (v TransactionMetaV2) XdrValue() interface{} { return v }
func (v *TransactionMetaV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChanges(&v.TxChangesBefore).XdrMarshal(x, x.Sprintf("%stxChangesBefore", name))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
	XDR_LedgerEntryChanges(&v.TxChangesAfter).XdrMarshal(x, x.Sprintf("%stxChangesAfter", name))
}
func XDR_TransactionMetaV2(v *TransactionMetaV2) *TransactionMetaV2 { return v }
func (u *TransactionMeta) Operations() *[]OperationMeta {
	switch u.V {
	case 0:
		if v, ok := u._u.(*[]OperationMeta); ok {
			return v
		} else {
			var zero []OperationMeta
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.Operations accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V1() *TransactionMetaV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*TransactionMetaV1); ok {
			return v
		} else {
			var zero TransactionMetaV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V2() *TransactionMetaV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*TransactionMetaV2); ok {
			return v
		} else {
			var zero TransactionMetaV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u TransactionMeta) XdrValid() bool {
	switch u.V {
	case 0,1,2:
		return true
	}
	return false
}
func (u *TransactionMeta) XdrUnionTag() interface{} {
	return &u.V
}
func (u *TransactionMeta) XdrUnionTagName() string {
	return "V"
}
func (u *TransactionMeta) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return u.Operations()
	case 1:
		return u.V1()
	case 2:
		return u.V2()
	}
	return nil
}
func (u *TransactionMeta) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "Operations"
	case 1:
		return "V1"
	case 2:
		return "V2"
	}
	return ""
}
func (v *TransactionMeta) XdrPointer() interface{} { return v }
func (v TransactionMeta) XdrValue() interface{} { return v }
func (v *TransactionMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TransactionMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(u.Operations()))
		return
	case 1:
		XDR_TransactionMetaV1(u.V1()).XdrMarshal(x, x.Sprintf("%sv1", name))
		return
	case 2:
		XDR_TransactionMetaV2(u.V2()).XdrMarshal(x, x.Sprintf("%sv2", name))
		return
	}
	XdrPanic("invalid V (%v) in TransactionMeta", u.V)
}
func XDR_TransactionMeta(v *TransactionMeta) *TransactionMeta { return v}
var _XdrNames_ErrorCode = map[int32]string{
	int32(ERR_MISC): "ERR_MISC",
	int32(ERR_DATA): "ERR_DATA",
	int32(ERR_CONF): "ERR_CONF",
	int32(ERR_AUTH): "ERR_AUTH",
	int32(ERR_LOAD): "ERR_LOAD",
}
var _XdrValues_ErrorCode = map[string]int32{
	"ERR_MISC": int32(ERR_MISC),
	"ERR_DATA": int32(ERR_DATA),
	"ERR_CONF": int32(ERR_CONF),
	"ERR_AUTH": int32(ERR_AUTH),
	"ERR_LOAD": int32(ERR_LOAD),
}
func (ErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ErrorCode
}
func (v ErrorCode) String() string {
	if s, ok := _XdrNames_ErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ErrorCode#%d", v)
}
func (v *ErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ErrorCode[stok]; ok {
			*v = ErrorCode(val)
			return nil
		} else if stok == "ErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ErrorCode.", stok))
	}
}
func (v ErrorCode) GetU32() uint32 { return uint32(v) }
func (v *ErrorCode) SetU32(n uint32) { *v = ErrorCode(n) }
func (v *ErrorCode) XdrPointer() interface{} { return v }
func (v ErrorCode) XdrValue() interface{} { return v }
func (v *ErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_ErrorCode(v *ErrorCode) *ErrorCode { return v }
var _XdrComments_ErrorCode = map[int32]string {
	int32(ERR_MISC): "Unspecific error",
	int32(ERR_DATA): "Malformed data",
	int32(ERR_CONF): "Misconfiguration error",
	int32(ERR_AUTH): "Authentication failure",
	int32(ERR_LOAD): "System overloaded",
}
func (e ErrorCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ErrorCode
}
func (v *Error) XdrPointer() interface{} { return v }
func (v Error) XdrValue() interface{} { return v }
func (v *Error) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Error) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ErrorCode(&v.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	x.Marshal(x.Sprintf("%smsg", name), XdrString{&v.Msg, 100})
}
func XDR_Error(v *Error) *Error { return v }
func (v *AuthCert) XdrPointer() interface{} { return v }
func (v AuthCert) XdrValue() interface{} { return v }
func (v *AuthCert) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AuthCert) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Curve25519Public(&v.Pubkey).XdrMarshal(x, x.Sprintf("%spubkey", name))
	XDR_Uint64(&v.Expiration).XdrMarshal(x, x.Sprintf("%sexpiration", name))
	XDR_Signature(&v.Sig).XdrMarshal(x, x.Sprintf("%ssig", name))
}
func XDR_AuthCert(v *AuthCert) *AuthCert { return v }
func (v *Hello) XdrPointer() interface{} { return v }
func (v Hello) XdrValue() interface{} { return v }
func (v *Hello) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Hello) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&v.LedgerVersion).XdrMarshal(x, x.Sprintf("%sledgerVersion", name))
	XDR_Uint32(&v.OverlayVersion).XdrMarshal(x, x.Sprintf("%soverlayVersion", name))
	XDR_Uint32(&v.OverlayMinVersion).XdrMarshal(x, x.Sprintf("%soverlayMinVersion", name))
	XDR_Hash(&v.NetworkID).XdrMarshal(x, x.Sprintf("%snetworkID", name))
	x.Marshal(x.Sprintf("%sversionStr", name), XdrString{&v.VersionStr, 100})
	XDR_int32(&v.ListeningPort).XdrMarshal(x, x.Sprintf("%slisteningPort", name))
	XDR_NodeID(&v.PeerID).XdrMarshal(x, x.Sprintf("%speerID", name))
	XDR_AuthCert(&v.Cert).XdrMarshal(x, x.Sprintf("%scert", name))
	XDR_Uint256(&v.Nonce).XdrMarshal(x, x.Sprintf("%snonce", name))
}
func XDR_Hello(v *Hello) *Hello { return v }
func (v *Auth) XdrPointer() interface{} { return v }
func (v Auth) XdrValue() interface{} { return v }
func (v *Auth) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Auth) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&v.Unused).XdrMarshal(x, x.Sprintf("%sunused", name))
}
func XDR_Auth(v *Auth) *Auth { return v }
var _XdrNames_IPAddrType = map[int32]string{
	int32(IPv4): "IPv4",
	int32(IPv6): "IPv6",
}
var _XdrValues_IPAddrType = map[string]int32{
	"IPv4": int32(IPv4),
	"IPv6": int32(IPv6),
}
func (IPAddrType) XdrEnumNames() map[int32]string {
	return _XdrNames_IPAddrType
}
func (v IPAddrType) String() string {
	if s, ok := _XdrNames_IPAddrType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("IPAddrType#%d", v)
}
func (v *IPAddrType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_IPAddrType[stok]; ok {
			*v = IPAddrType(val)
			return nil
		} else if stok == "IPAddrType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid IPAddrType.", stok))
	}
}
func (v IPAddrType) GetU32() uint32 { return uint32(v) }
func (v *IPAddrType) SetU32(n uint32) { *v = IPAddrType(n) }
func (v *IPAddrType) XdrPointer() interface{} { return v }
func (v IPAddrType) XdrValue() interface{} { return v }
func (v *IPAddrType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_IPAddrType(v *IPAddrType) *IPAddrType { return v }
func (u *XdrAnon_PeerAddress_Ip) Ipv4() *[4]byte {
	switch u.Type {
	case IPv4:
		if v, ok := u._u.(*[4]byte); ok {
			return v
		} else {
			var zero [4]byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_PeerAddress_Ip.Ipv4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_PeerAddress_Ip) Ipv6() *[16]byte {
	switch u.Type {
	case IPv6:
		if v, ok := u._u.(*[16]byte); ok {
			return v
		} else {
			var zero [16]byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_PeerAddress_Ip.Ipv6 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_PeerAddress_Ip) XdrValid() bool {
	switch u.Type {
	case IPv4,IPv6:
		return true
	}
	return false
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionBody() interface{} {
	switch u.Type {
	case IPv4:
		return u.Ipv4()
	case IPv6:
		return u.Ipv6()
	}
	return nil
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionBodyName() string {
	switch u.Type {
	case IPv4:
		return "Ipv4"
	case IPv6:
		return "Ipv6"
	}
	return ""
}
func (v *XdrAnon_PeerAddress_Ip) XdrPointer() interface{} { return v }
func (v XdrAnon_PeerAddress_Ip) XdrValue() interface{} { return v }
func (v *XdrAnon_PeerAddress_Ip) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_PeerAddress_Ip) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_IPAddrType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case IPv4:
		x.Marshal(x.Sprintf("%sipv4", name), XdrArrayOpaque((*u.Ipv4())[:]))
		return
	case IPv6:
		x.Marshal(x.Sprintf("%sipv6", name), XdrArrayOpaque((*u.Ipv6())[:]))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_PeerAddress_Ip", u.Type)
}
func XDR_XdrAnon_PeerAddress_Ip(v *XdrAnon_PeerAddress_Ip) *XdrAnon_PeerAddress_Ip { return v}
func (v *PeerAddress) XdrPointer() interface{} { return v }
func (v PeerAddress) XdrValue() interface{} { return v }
func (v *PeerAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PeerAddress) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_XdrAnon_PeerAddress_Ip(&v.Ip).XdrMarshal(x, x.Sprintf("%sip", name))
	XDR_Uint32(&v.Port).XdrMarshal(x, x.Sprintf("%sport", name))
	XDR_Uint32(&v.NumFailures).XdrMarshal(x, x.Sprintf("%snumFailures", name))
}
func XDR_PeerAddress(v *PeerAddress) *PeerAddress { return v }
var _XdrNames_MessageType = map[int32]string{
	int32(ERROR_MSG): "ERROR_MSG",
	int32(AUTH): "AUTH",
	int32(DONT_HAVE): "DONT_HAVE",
	int32(GET_PEERS): "GET_PEERS",
	int32(PEERS): "PEERS",
	int32(GET_TX_SET): "GET_TX_SET",
	int32(TX_SET): "TX_SET",
	int32(TRANSACTION): "TRANSACTION",
	int32(GET_SCP_QUORUMSET): "GET_SCP_QUORUMSET",
	int32(SCP_QUORUMSET): "SCP_QUORUMSET",
	int32(SCP_MESSAGE): "SCP_MESSAGE",
	int32(GET_SCP_STATE): "GET_SCP_STATE",
	int32(HELLO): "HELLO",
}
var _XdrValues_MessageType = map[string]int32{
	"ERROR_MSG": int32(ERROR_MSG),
	"AUTH": int32(AUTH),
	"DONT_HAVE": int32(DONT_HAVE),
	"GET_PEERS": int32(GET_PEERS),
	"PEERS": int32(PEERS),
	"GET_TX_SET": int32(GET_TX_SET),
	"TX_SET": int32(TX_SET),
	"TRANSACTION": int32(TRANSACTION),
	"GET_SCP_QUORUMSET": int32(GET_SCP_QUORUMSET),
	"SCP_QUORUMSET": int32(SCP_QUORUMSET),
	"SCP_MESSAGE": int32(SCP_MESSAGE),
	"GET_SCP_STATE": int32(GET_SCP_STATE),
	"HELLO": int32(HELLO),
}
func (MessageType) XdrEnumNames() map[int32]string {
	return _XdrNames_MessageType
}
func (v MessageType) String() string {
	if s, ok := _XdrNames_MessageType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("MessageType#%d", v)
}
func (v *MessageType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MessageType[stok]; ok {
			*v = MessageType(val)
			return nil
		} else if stok == "MessageType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid MessageType.", stok))
	}
}
func (v MessageType) GetU32() uint32 { return uint32(v) }
func (v *MessageType) SetU32(n uint32) { *v = MessageType(n) }
func (v *MessageType) XdrPointer() interface{} { return v }
func (v MessageType) XdrValue() interface{} { return v }
func (v *MessageType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_MessageType(v *MessageType) *MessageType { return v }
var _XdrComments_MessageType = map[int32]string {
	int32(GET_PEERS): "gets a list of peers this guy knows about",
	int32(GET_TX_SET): "gets a particular txset by hash",
	int32(TRANSACTION): "pass on a tx you have heard about",
	int32(GET_SCP_QUORUMSET): "SCP",
	int32(HELLO): "new messages",
}
func (e MessageType) XdrEnumComments() map[int32]string {
	return _XdrComments_MessageType
}
func (v *DontHave) XdrPointer() interface{} { return v }
func (v DontHave) XdrValue() interface{} { return v }
func (v *DontHave) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DontHave) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MessageType(&v.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	XDR_Uint256(&v.ReqHash).XdrMarshal(x, x.Sprintf("%sreqHash", name))
}
func XDR_DontHave(v *DontHave) *DontHave { return v }
type _XdrVec_100_PeerAddress []PeerAddress
func (_XdrVec_100_PeerAddress) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_100_PeerAddress) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		XdrPanic("_XdrVec_100_PeerAddress length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_100_PeerAddress length %d exceeds max int", length)
	}
}
func (v _XdrVec_100_PeerAddress) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_100_PeerAddress) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PeerAddress, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_100_PeerAddress) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_PeerAddress(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_100_PeerAddress) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 100 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_100_PeerAddress) XdrPointer() interface{} { return (*[]PeerAddress)(v) }
func (v _XdrVec_100_PeerAddress) XdrValue() interface{} { return ([]PeerAddress)(v) }
func (v *_XdrVec_100_PeerAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *StellarMessage) Error() *Error {
	switch u.Type {
	case ERROR_MSG:
		if v, ok := u._u.(*Error); ok {
			return v
		} else {
			var zero Error
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Error accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Hello() *Hello {
	switch u.Type {
	case HELLO:
		if v, ok := u._u.(*Hello); ok {
			return v
		} else {
			var zero Hello
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Hello accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Auth() *Auth {
	switch u.Type {
	case AUTH:
		if v, ok := u._u.(*Auth); ok {
			return v
		} else {
			var zero Auth
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Auth accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) DontHave() *DontHave {
	switch u.Type {
	case DONT_HAVE:
		if v, ok := u._u.(*DontHave); ok {
			return v
		} else {
			var zero DontHave
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.DontHave accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Peers() *[]PeerAddress {
	switch u.Type {
	case PEERS:
		if v, ok := u._u.(*[]PeerAddress); ok {
			return v
		} else {
			var zero []PeerAddress
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Peers accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSetHash() *Uint256 {
	switch u.Type {
	case GET_TX_SET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.TxSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSet() *TransactionSet {
	switch u.Type {
	case TX_SET:
		if v, ok := u._u.(*TransactionSet); ok {
			return v
		} else {
			var zero TransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.TxSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Transaction() *TransactionEnvelope {
	switch u.Type {
	case TRANSACTION:
		if v, ok := u._u.(*TransactionEnvelope); ok {
			return v
		} else {
			var zero TransactionEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Transaction accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSetHash() *Uint256 {
	switch u.Type {
	case GET_SCP_QUORUMSET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.QSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSet() *SCPQuorumSet {
	switch u.Type {
	case SCP_QUORUMSET:
		if v, ok := u._u.(*SCPQuorumSet); ok {
			return v
		} else {
			var zero SCPQuorumSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.QSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Envelope() *SCPEnvelope {
	switch u.Type {
	case SCP_MESSAGE:
		if v, ok := u._u.(*SCPEnvelope); ok {
			return v
		} else {
			var zero SCPEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Envelope accessed when Type == %v", u.Type)
		return nil
	}
}
// ledger seq requested ; if 0, requests the latest
func (u *StellarMessage) GetSCPLedgerSeq() *Uint32 {
	switch u.Type {
	case GET_SCP_STATE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.GetSCPLedgerSeq accessed when Type == %v", u.Type)
		return nil
	}
}
func (u StellarMessage) XdrValid() bool {
	switch u.Type {
	case ERROR_MSG,HELLO,AUTH,DONT_HAVE,GET_PEERS,PEERS,GET_TX_SET,TX_SET,TRANSACTION,GET_SCP_QUORUMSET,SCP_QUORUMSET,SCP_MESSAGE,GET_SCP_STATE:
		return true
	}
	return false
}
func (u *StellarMessage) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *StellarMessage) XdrUnionTagName() string {
	return "Type"
}
func (u *StellarMessage) XdrUnionBody() interface{} {
	switch u.Type {
	case ERROR_MSG:
		return u.Error()
	case HELLO:
		return u.Hello()
	case AUTH:
		return u.Auth()
	case DONT_HAVE:
		return u.DontHave()
	case GET_PEERS:
		return nil
	case PEERS:
		return u.Peers()
	case GET_TX_SET:
		return u.TxSetHash()
	case TX_SET:
		return u.TxSet()
	case TRANSACTION:
		return u.Transaction()
	case GET_SCP_QUORUMSET:
		return u.QSetHash()
	case SCP_QUORUMSET:
		return u.QSet()
	case SCP_MESSAGE:
		return u.Envelope()
	case GET_SCP_STATE:
		return u.GetSCPLedgerSeq()
	}
	return nil
}
func (u *StellarMessage) XdrUnionBodyName() string {
	switch u.Type {
	case ERROR_MSG:
		return "Error"
	case HELLO:
		return "Hello"
	case AUTH:
		return "Auth"
	case DONT_HAVE:
		return "DontHave"
	case GET_PEERS:
		return ""
	case PEERS:
		return "Peers"
	case GET_TX_SET:
		return "TxSetHash"
	case TX_SET:
		return "TxSet"
	case TRANSACTION:
		return "Transaction"
	case GET_SCP_QUORUMSET:
		return "QSetHash"
	case SCP_QUORUMSET:
		return "QSet"
	case SCP_MESSAGE:
		return "Envelope"
	case GET_SCP_STATE:
		return "GetSCPLedgerSeq"
	}
	return ""
}
func (v *StellarMessage) XdrPointer() interface{} { return v }
func (v StellarMessage) XdrValue() interface{} { return v }
func (v *StellarMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *StellarMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MessageType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ERROR_MSG:
		XDR_Error(u.Error()).XdrMarshal(x, x.Sprintf("%serror", name))
		return
	case HELLO:
		XDR_Hello(u.Hello()).XdrMarshal(x, x.Sprintf("%shello", name))
		return
	case AUTH:
		XDR_Auth(u.Auth()).XdrMarshal(x, x.Sprintf("%sauth", name))
		return
	case DONT_HAVE:
		XDR_DontHave(u.DontHave()).XdrMarshal(x, x.Sprintf("%sdontHave", name))
		return
	case GET_PEERS:
		return
	case PEERS:
		x.Marshal(x.Sprintf("%speers", name), (*_XdrVec_100_PeerAddress)(u.Peers()))
		return
	case GET_TX_SET:
		XDR_Uint256(u.TxSetHash()).XdrMarshal(x, x.Sprintf("%stxSetHash", name))
		return
	case TX_SET:
		XDR_TransactionSet(u.TxSet()).XdrMarshal(x, x.Sprintf("%stxSet", name))
		return
	case TRANSACTION:
		XDR_TransactionEnvelope(u.Transaction()).XdrMarshal(x, x.Sprintf("%stransaction", name))
		return
	case GET_SCP_QUORUMSET:
		XDR_Uint256(u.QSetHash()).XdrMarshal(x, x.Sprintf("%sqSetHash", name))
		return
	case SCP_QUORUMSET:
		XDR_SCPQuorumSet(u.QSet()).XdrMarshal(x, x.Sprintf("%sqSet", name))
		return
	case SCP_MESSAGE:
		XDR_SCPEnvelope(u.Envelope()).XdrMarshal(x, x.Sprintf("%senvelope", name))
		return
	case GET_SCP_STATE:
		XDR_Uint32(u.GetSCPLedgerSeq()).XdrMarshal(x, x.Sprintf("%sgetSCPLedgerSeq", name))
		return
	}
	XdrPanic("invalid Type (%v) in StellarMessage", u.Type)
}
func XDR_StellarMessage(v *StellarMessage) *StellarMessage { return v}
func (v *XdrAnon_AuthenticatedMessage_V0) XdrPointer() interface{} { return v }
func (v XdrAnon_AuthenticatedMessage_V0) XdrValue() interface{} { return v }
func (v *XdrAnon_AuthenticatedMessage_V0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_AuthenticatedMessage_V0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint64(&v.Sequence).XdrMarshal(x, x.Sprintf("%ssequence", name))
	XDR_StellarMessage(&v.Message).XdrMarshal(x, x.Sprintf("%smessage", name))
	XDR_HmacSha256Mac(&v.Mac).XdrMarshal(x, x.Sprintf("%smac", name))
}
func XDR_XdrAnon_AuthenticatedMessage_V0(v *XdrAnon_AuthenticatedMessage_V0) *XdrAnon_AuthenticatedMessage_V0 { return v }
func (u *AuthenticatedMessage) V0() *XdrAnon_AuthenticatedMessage_V0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*XdrAnon_AuthenticatedMessage_V0); ok {
			return v
		} else {
			var zero XdrAnon_AuthenticatedMessage_V0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AuthenticatedMessage.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u AuthenticatedMessage) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *AuthenticatedMessage) XdrUnionTag() interface{} {
	return &u.V
}
func (u *AuthenticatedMessage) XdrUnionTagName() string {
	return "V"
}
func (u *AuthenticatedMessage) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return u.V0()
	}
	return nil
}
func (u *AuthenticatedMessage) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}
func (v *AuthenticatedMessage) XdrPointer() interface{} { return v }
func (v AuthenticatedMessage) XdrValue() interface{} { return v }
func (v *AuthenticatedMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AuthenticatedMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		XDR_XdrAnon_AuthenticatedMessage_V0(u.V0()).XdrMarshal(x, x.Sprintf("%sv0", name))
		return
	}
	XdrPanic("invalid V (%v) in AuthenticatedMessage", u.V)
}
func XDR_AuthenticatedMessage(v *AuthenticatedMessage) *AuthenticatedMessage { return v}
func (v *DecoratedSignature) XdrPointer() interface{} { return v }
func (v DecoratedSignature) XdrValue() interface{} { return v }
func (v *DecoratedSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DecoratedSignature) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignatureHint(&v.Hint).XdrMarshal(x, x.Sprintf("%shint", name))
	XDR_Signature(&v.Signature).XdrMarshal(x, x.Sprintf("%ssignature", name))
}
func XDR_DecoratedSignature(v *DecoratedSignature) *DecoratedSignature { return v }
var _XdrNames_OperationType = map[int32]string{
	int32(CREATE_ACCOUNT): "CREATE_ACCOUNT",
	int32(PAYMENT): "PAYMENT",
	int32(PATH_PAYMENT_STRICT_RECEIVE): "PATH_PAYMENT_STRICT_RECEIVE",
	int32(MANAGE_SELL_OFFER): "MANAGE_SELL_OFFER",
	int32(CREATE_PASSIVE_SELL_OFFER): "CREATE_PASSIVE_SELL_OFFER",
	int32(SET_OPTIONS): "SET_OPTIONS",
	int32(CHANGE_TRUST): "CHANGE_TRUST",
	int32(ALLOW_TRUST): "ALLOW_TRUST",
	int32(ACCOUNT_MERGE): "ACCOUNT_MERGE",
	int32(INFLATION): "INFLATION",
	int32(MANAGE_DATA): "MANAGE_DATA",
	int32(BUMP_SEQUENCE): "BUMP_SEQUENCE",
	int32(MANAGE_BUY_OFFER): "MANAGE_BUY_OFFER",
	int32(PATH_PAYMENT_STRICT_SEND): "PATH_PAYMENT_STRICT_SEND",
}
var _XdrValues_OperationType = map[string]int32{
	"CREATE_ACCOUNT": int32(CREATE_ACCOUNT),
	"PAYMENT": int32(PAYMENT),
	"PATH_PAYMENT_STRICT_RECEIVE": int32(PATH_PAYMENT_STRICT_RECEIVE),
	"MANAGE_SELL_OFFER": int32(MANAGE_SELL_OFFER),
	"CREATE_PASSIVE_SELL_OFFER": int32(CREATE_PASSIVE_SELL_OFFER),
	"SET_OPTIONS": int32(SET_OPTIONS),
	"CHANGE_TRUST": int32(CHANGE_TRUST),
	"ALLOW_TRUST": int32(ALLOW_TRUST),
	"ACCOUNT_MERGE": int32(ACCOUNT_MERGE),
	"INFLATION": int32(INFLATION),
	"MANAGE_DATA": int32(MANAGE_DATA),
	"BUMP_SEQUENCE": int32(BUMP_SEQUENCE),
	"MANAGE_BUY_OFFER": int32(MANAGE_BUY_OFFER),
	"PATH_PAYMENT_STRICT_SEND": int32(PATH_PAYMENT_STRICT_SEND),
}
func (OperationType) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationType
}
func (v OperationType) String() string {
	if s, ok := _XdrNames_OperationType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationType#%d", v)
}
func (v *OperationType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationType[stok]; ok {
			*v = OperationType(val)
			return nil
		} else if stok == "OperationType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationType.", stok))
	}
}
func (v OperationType) GetU32() uint32 { return uint32(v) }
func (v *OperationType) SetU32(n uint32) { *v = OperationType(n) }
func (v *OperationType) XdrPointer() interface{} { return v }
func (v OperationType) XdrValue() interface{} { return v }
func (v *OperationType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_OperationType(v *OperationType) *OperationType { return v }
func (v *CreateAccountOp) XdrPointer() interface{} { return v }
func (v CreateAccountOp) XdrValue() interface{} { return v }
func (v *CreateAccountOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreateAccountOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.Destination).XdrMarshal(x, x.Sprintf("%sdestination", name))
	XDR_Int64(&v.StartingBalance).XdrMarshal(x, x.Sprintf("%sstartingBalance", name))
}
func XDR_CreateAccountOp(v *CreateAccountOp) *CreateAccountOp { return v }
func (v *PaymentOp) XdrPointer() interface{} { return v }
func (v PaymentOp) XdrValue() interface{} { return v }
func (v *PaymentOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PaymentOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.Destination).XdrMarshal(x, x.Sprintf("%sdestination", name))
	XDR_Asset(&v.Asset).XdrMarshal(x, x.Sprintf("%sasset", name))
	XDR_Int64(&v.Amount).XdrMarshal(x, x.Sprintf("%samount", name))
}
func XDR_PaymentOp(v *PaymentOp) *PaymentOp { return v }
type _XdrVec_5_Asset []Asset
func (_XdrVec_5_Asset) XdrBound() uint32 {
	const bound uint32 = 5 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_5_Asset) XdrCheckLen(length uint32) {
	if length > uint32(5) {
		XdrPanic("_XdrVec_5_Asset length %d exceeds bound 5", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_5_Asset length %d exceeds max int", length)
	}
}
func (v _XdrVec_5_Asset) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_5_Asset) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(5); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Asset, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_5_Asset) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Asset(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_5_Asset) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 5 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_5_Asset) XdrPointer() interface{} { return (*[]Asset)(v) }
func (v _XdrVec_5_Asset) XdrValue() interface{} { return ([]Asset)(v) }
func (v *_XdrVec_5_Asset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PathPaymentStrictReceiveOp) XdrPointer() interface{} { return v }
func (v PathPaymentStrictReceiveOp) XdrValue() interface{} { return v }
func (v *PathPaymentStrictReceiveOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PathPaymentStrictReceiveOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(&v.SendAsset).XdrMarshal(x, x.Sprintf("%ssendAsset", name))
	XDR_Int64(&v.SendMax).XdrMarshal(x, x.Sprintf("%ssendMax", name))
	XDR_AccountID(&v.Destination).XdrMarshal(x, x.Sprintf("%sdestination", name))
	XDR_Asset(&v.DestAsset).XdrMarshal(x, x.Sprintf("%sdestAsset", name))
	XDR_Int64(&v.DestAmount).XdrMarshal(x, x.Sprintf("%sdestAmount", name))
	x.Marshal(x.Sprintf("%spath", name), (*_XdrVec_5_Asset)(&v.Path))
}
func XDR_PathPaymentStrictReceiveOp(v *PathPaymentStrictReceiveOp) *PathPaymentStrictReceiveOp { return v }
func (v *PathPaymentStrictSendOp) XdrPointer() interface{} { return v }
func (v PathPaymentStrictSendOp) XdrValue() interface{} { return v }
func (v *PathPaymentStrictSendOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PathPaymentStrictSendOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(&v.SendAsset).XdrMarshal(x, x.Sprintf("%ssendAsset", name))
	XDR_Int64(&v.SendAmount).XdrMarshal(x, x.Sprintf("%ssendAmount", name))
	XDR_AccountID(&v.Destination).XdrMarshal(x, x.Sprintf("%sdestination", name))
	XDR_Asset(&v.DestAsset).XdrMarshal(x, x.Sprintf("%sdestAsset", name))
	XDR_Int64(&v.DestMin).XdrMarshal(x, x.Sprintf("%sdestMin", name))
	x.Marshal(x.Sprintf("%spath", name), (*_XdrVec_5_Asset)(&v.Path))
}
func XDR_PathPaymentStrictSendOp(v *PathPaymentStrictSendOp) *PathPaymentStrictSendOp { return v }
func (v *ManageSellOfferOp) XdrPointer() interface{} { return v }
func (v ManageSellOfferOp) XdrValue() interface{} { return v }
func (v *ManageSellOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageSellOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(&v.Selling).XdrMarshal(x, x.Sprintf("%sselling", name))
	XDR_Asset(&v.Buying).XdrMarshal(x, x.Sprintf("%sbuying", name))
	XDR_Int64(&v.Amount).XdrMarshal(x, x.Sprintf("%samount", name))
	XDR_Price(&v.Price).XdrMarshal(x, x.Sprintf("%sprice", name))
	XDR_Int64(&v.OfferID).XdrMarshal(x, x.Sprintf("%sofferID", name))
}
func XDR_ManageSellOfferOp(v *ManageSellOfferOp) *ManageSellOfferOp { return v }
func (v *ManageBuyOfferOp) XdrPointer() interface{} { return v }
func (v ManageBuyOfferOp) XdrValue() interface{} { return v }
func (v *ManageBuyOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageBuyOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(&v.Selling).XdrMarshal(x, x.Sprintf("%sselling", name))
	XDR_Asset(&v.Buying).XdrMarshal(x, x.Sprintf("%sbuying", name))
	XDR_Int64(&v.BuyAmount).XdrMarshal(x, x.Sprintf("%sbuyAmount", name))
	XDR_Price(&v.Price).XdrMarshal(x, x.Sprintf("%sprice", name))
	XDR_Int64(&v.OfferID).XdrMarshal(x, x.Sprintf("%sofferID", name))
}
func XDR_ManageBuyOfferOp(v *ManageBuyOfferOp) *ManageBuyOfferOp { return v }
func (v *CreatePassiveSellOfferOp) XdrPointer() interface{} { return v }
func (v CreatePassiveSellOfferOp) XdrValue() interface{} { return v }
func (v *CreatePassiveSellOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreatePassiveSellOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(&v.Selling).XdrMarshal(x, x.Sprintf("%sselling", name))
	XDR_Asset(&v.Buying).XdrMarshal(x, x.Sprintf("%sbuying", name))
	XDR_Int64(&v.Amount).XdrMarshal(x, x.Sprintf("%samount", name))
	XDR_Price(&v.Price).XdrMarshal(x, x.Sprintf("%sprice", name))
}
func XDR_CreatePassiveSellOfferOp(v *CreatePassiveSellOfferOp) *CreatePassiveSellOfferOp { return v }
type _XdrPtr_Uint32 struct {
	p **Uint32
}
type _ptrflag_Uint32 _XdrPtr_Uint32
func (v _ptrflag_Uint32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Uint32) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Uint32 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Uint32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Uint32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Uint32)
		}
	default:
		XdrPanic("*Uint32 present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_Uint32) XdrPointer() interface{} { return nil }
func (v _ptrflag_Uint32) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_Uint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Uint32) XdrBound() uint32 { return 1 }
func (v _XdrPtr_Uint32) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_Uint32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Uint32)
	}
}
func (v _XdrPtr_Uint32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Uint32(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Uint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Uint32) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Uint32(v))
	v.XdrMarshalValue(x, name)
}
func (v _XdrPtr_Uint32) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Uint32) XdrValue() interface{} { return *v.p }
type _XdrPtr_String32 struct {
	p **String32
}
type _ptrflag_String32 _XdrPtr_String32
func (v _ptrflag_String32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_String32) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("String32 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_String32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_String32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(String32)
		}
	default:
		XdrPanic("*String32 present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_String32) XdrPointer() interface{} { return nil }
func (v _ptrflag_String32) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_String32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_String32) XdrBound() uint32 { return 1 }
func (v _XdrPtr_String32) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_String32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(String32)
	}
}
func (v _XdrPtr_String32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_String32(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_String32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_String32) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_String32(v))
	v.XdrMarshalValue(x, name)
}
func (v _XdrPtr_String32) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_String32) XdrValue() interface{} { return *v.p }
type _XdrPtr_Signer struct {
	p **Signer
}
type _ptrflag_Signer _XdrPtr_Signer
func (v _ptrflag_Signer) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Signer) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Signer flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Signer) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Signer) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Signer)
		}
	default:
		XdrPanic("*Signer present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_Signer) XdrPointer() interface{} { return nil }
func (v _ptrflag_Signer) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Signer) XdrBound() uint32 { return 1 }
func (v _XdrPtr_Signer) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_Signer) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Signer)
	}
}
func (v _XdrPtr_Signer) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Signer(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Signer) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Signer(v))
	v.XdrMarshalValue(x, name)
}
func (v _XdrPtr_Signer) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Signer) XdrValue() interface{} { return *v.p }
func (v *SetOptionsOp) XdrPointer() interface{} { return v }
func (v SetOptionsOp) XdrValue() interface{} { return v }
func (v *SetOptionsOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SetOptionsOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinflationDest", name), _XdrPtr_AccountID{&v.InflationDest})
	x.Marshal(x.Sprintf("%sclearFlags", name), _XdrPtr_Uint32{&v.ClearFlags})
	x.Marshal(x.Sprintf("%ssetFlags", name), _XdrPtr_Uint32{&v.SetFlags})
	x.Marshal(x.Sprintf("%smasterWeight", name), _XdrPtr_Uint32{&v.MasterWeight})
	x.Marshal(x.Sprintf("%slowThreshold", name), _XdrPtr_Uint32{&v.LowThreshold})
	x.Marshal(x.Sprintf("%smedThreshold", name), _XdrPtr_Uint32{&v.MedThreshold})
	x.Marshal(x.Sprintf("%shighThreshold", name), _XdrPtr_Uint32{&v.HighThreshold})
	x.Marshal(x.Sprintf("%shomeDomain", name), _XdrPtr_String32{&v.HomeDomain})
	x.Marshal(x.Sprintf("%ssigner", name), _XdrPtr_Signer{&v.Signer})
}
func XDR_SetOptionsOp(v *SetOptionsOp) *SetOptionsOp { return v }
func (v *ChangeTrustOp) XdrPointer() interface{} { return v }
func (v ChangeTrustOp) XdrValue() interface{} { return v }
func (v *ChangeTrustOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ChangeTrustOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(&v.Line).XdrMarshal(x, x.Sprintf("%sline", name))
	XDR_Int64(&v.Limit).XdrMarshal(x, x.Sprintf("%slimit", name))
}
func XDR_ChangeTrustOp(v *ChangeTrustOp) *ChangeTrustOp { return v }
func (u *XdrAnon_AllowTrustOp_Asset) AssetCode4() *AssetCode4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AssetCode4); ok {
			return v
		} else {
			var zero AssetCode4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AllowTrustOp_Asset.AssetCode4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_AllowTrustOp_Asset) AssetCode12() *AssetCode12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AssetCode12); ok {
			return v
		} else {
			var zero AssetCode12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AllowTrustOp_Asset.AssetCode12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_AllowTrustOp_Asset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4,ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *XdrAnon_AllowTrustOp_Asset) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *XdrAnon_AllowTrustOp_Asset) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_AllowTrustOp_Asset) XdrUnionBody() interface{} {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return u.AssetCode4()
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return u.AssetCode12()
	}
	return nil
}
func (u *XdrAnon_AllowTrustOp_Asset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AssetCode4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AssetCode12"
	}
	return ""
}
func (v *XdrAnon_AllowTrustOp_Asset) XdrPointer() interface{} { return v }
func (v XdrAnon_AllowTrustOp_Asset) XdrValue() interface{} { return v }
func (v *XdrAnon_AllowTrustOp_Asset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AllowTrustOp_Asset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		XDR_AssetCode4(u.AssetCode4()).XdrMarshal(x, x.Sprintf("%sassetCode4", name))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		XDR_AssetCode12(u.AssetCode12()).XdrMarshal(x, x.Sprintf("%sassetCode12", name))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_AllowTrustOp_Asset", u.Type)
}
func (v *XdrAnon_AllowTrustOp_Asset) XdrInitialize() {
	var zero AssetType
	switch zero {
	case ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12:
	default:
		if v.Type == zero { v.Type = ASSET_TYPE_CREDIT_ALPHANUM4 }
	}
}
func XDR_XdrAnon_AllowTrustOp_Asset(v *XdrAnon_AllowTrustOp_Asset) *XdrAnon_AllowTrustOp_Asset { return v}
func (v *AllowTrustOp) XdrPointer() interface{} { return v }
func (v AllowTrustOp) XdrValue() interface{} { return v }
func (v *AllowTrustOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AllowTrustOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.Trustor).XdrMarshal(x, x.Sprintf("%strustor", name))
	XDR_XdrAnon_AllowTrustOp_Asset(&v.Asset).XdrMarshal(x, x.Sprintf("%sasset", name))
	XDR_bool(&v.Authorize).XdrMarshal(x, x.Sprintf("%sauthorize", name))
}
func XDR_AllowTrustOp(v *AllowTrustOp) *AllowTrustOp { return v }
type _XdrPtr_DataValue struct {
	p **DataValue
}
type _ptrflag_DataValue _XdrPtr_DataValue
func (v _ptrflag_DataValue) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_DataValue) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("DataValue flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_DataValue) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_DataValue) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(DataValue)
		}
	default:
		XdrPanic("*DataValue present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_DataValue) XdrPointer() interface{} { return nil }
func (v _ptrflag_DataValue) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_DataValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_DataValue) XdrBound() uint32 { return 1 }
func (v _XdrPtr_DataValue) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_DataValue) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(DataValue)
	}
}
func (v _XdrPtr_DataValue) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_DataValue(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_DataValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_DataValue) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_DataValue(v))
	v.XdrMarshalValue(x, name)
}
func (v _XdrPtr_DataValue) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_DataValue) XdrValue() interface{} { return *v.p }
func (v *ManageDataOp) XdrPointer() interface{} { return v }
func (v ManageDataOp) XdrValue() interface{} { return v }
func (v *ManageDataOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageDataOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_String64(&v.DataName).XdrMarshal(x, x.Sprintf("%sdataName", name))
	x.Marshal(x.Sprintf("%sdataValue", name), _XdrPtr_DataValue{&v.DataValue})
}
func XDR_ManageDataOp(v *ManageDataOp) *ManageDataOp { return v }
func (v *BumpSequenceOp) XdrPointer() interface{} { return v }
func (v BumpSequenceOp) XdrValue() interface{} { return v }
func (v *BumpSequenceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BumpSequenceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SequenceNumber(&v.BumpTo).XdrMarshal(x, x.Sprintf("%sbumpTo", name))
}
func XDR_BumpSequenceOp(v *BumpSequenceOp) *BumpSequenceOp { return v }
func (u *XdrAnon_Operation_Body) CreateAccountOp() *CreateAccountOp {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountOp); ok {
			return v
		} else {
			var zero CreateAccountOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreateAccountOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PaymentOp() *PaymentOp {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentOp); ok {
			return v
		} else {
			var zero PaymentOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PaymentOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PathPaymentStrictReceiveOp() *PathPaymentStrictReceiveOp {
	switch u.Type {
	case PATH_PAYMENT_STRICT_RECEIVE:
		if v, ok := u._u.(*PathPaymentStrictReceiveOp); ok {
			return v
		} else {
			var zero PathPaymentStrictReceiveOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PathPaymentStrictReceiveOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageSellOfferOp() *ManageSellOfferOp {
	switch u.Type {
	case MANAGE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferOp); ok {
			return v
		} else {
			var zero ManageSellOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageSellOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) CreatePassiveSellOfferOp() *CreatePassiveSellOfferOp {
	switch u.Type {
	case CREATE_PASSIVE_SELL_OFFER:
		if v, ok := u._u.(*CreatePassiveSellOfferOp); ok {
			return v
		} else {
			var zero CreatePassiveSellOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreatePassiveSellOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) SetOptionsOp() *SetOptionsOp {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsOp); ok {
			return v
		} else {
			var zero SetOptionsOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.SetOptionsOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ChangeTrustOp() *ChangeTrustOp {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustOp); ok {
			return v
		} else {
			var zero ChangeTrustOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ChangeTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) AllowTrustOp() *AllowTrustOp {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustOp); ok {
			return v
		} else {
			var zero AllowTrustOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.AllowTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) Destination() *AccountID {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*AccountID); ok {
			return v
		} else {
			var zero AccountID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.Destination accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageDataOp() *ManageDataOp {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataOp); ok {
			return v
		} else {
			var zero ManageDataOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageDataOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) BumpSequenceOp() *BumpSequenceOp {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceOp); ok {
			return v
		} else {
			var zero BumpSequenceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.BumpSequenceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageBuyOfferOp() *ManageBuyOfferOp {
	switch u.Type {
	case MANAGE_BUY_OFFER:
		if v, ok := u._u.(*ManageBuyOfferOp); ok {
			return v
		} else {
			var zero ManageBuyOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageBuyOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PathPaymentStrictSendOp() *PathPaymentStrictSendOp {
	switch u.Type {
	case PATH_PAYMENT_STRICT_SEND:
		if v, ok := u._u.(*PathPaymentStrictSendOp); ok {
			return v
		} else {
			var zero PathPaymentStrictSendOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PathPaymentStrictSendOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_Operation_Body) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT,PAYMENT,PATH_PAYMENT_STRICT_RECEIVE,MANAGE_SELL_OFFER,CREATE_PASSIVE_SELL_OFFER,SET_OPTIONS,CHANGE_TRUST,ALLOW_TRUST,ACCOUNT_MERGE,INFLATION,MANAGE_DATA,BUMP_SEQUENCE,MANAGE_BUY_OFFER,PATH_PAYMENT_STRICT_SEND:
		return true
	}
	return false
}
func (u *XdrAnon_Operation_Body) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *XdrAnon_Operation_Body) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_Operation_Body) XdrUnionBody() interface{} {
	switch u.Type {
	case CREATE_ACCOUNT:
		return u.CreateAccountOp()
	case PAYMENT:
		return u.PaymentOp()
	case PATH_PAYMENT_STRICT_RECEIVE:
		return u.PathPaymentStrictReceiveOp()
	case MANAGE_SELL_OFFER:
		return u.ManageSellOfferOp()
	case CREATE_PASSIVE_SELL_OFFER:
		return u.CreatePassiveSellOfferOp()
	case SET_OPTIONS:
		return u.SetOptionsOp()
	case CHANGE_TRUST:
		return u.ChangeTrustOp()
	case ALLOW_TRUST:
		return u.AllowTrustOp()
	case ACCOUNT_MERGE:
		return u.Destination()
	case INFLATION:
		return nil
	case MANAGE_DATA:
		return u.ManageDataOp()
	case BUMP_SEQUENCE:
		return u.BumpSequenceOp()
	case MANAGE_BUY_OFFER:
		return u.ManageBuyOfferOp()
	case PATH_PAYMENT_STRICT_SEND:
		return u.PathPaymentStrictSendOp()
	}
	return nil
}
func (u *XdrAnon_Operation_Body) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountOp"
	case PAYMENT:
		return "PaymentOp"
	case PATH_PAYMENT_STRICT_RECEIVE:
		return "PathPaymentStrictReceiveOp"
	case MANAGE_SELL_OFFER:
		return "ManageSellOfferOp"
	case CREATE_PASSIVE_SELL_OFFER:
		return "CreatePassiveSellOfferOp"
	case SET_OPTIONS:
		return "SetOptionsOp"
	case CHANGE_TRUST:
		return "ChangeTrustOp"
	case ALLOW_TRUST:
		return "AllowTrustOp"
	case ACCOUNT_MERGE:
		return "Destination"
	case INFLATION:
		return ""
	case MANAGE_DATA:
		return "ManageDataOp"
	case BUMP_SEQUENCE:
		return "BumpSequenceOp"
	case MANAGE_BUY_OFFER:
		return "ManageBuyOfferOp"
	case PATH_PAYMENT_STRICT_SEND:
		return "PathPaymentStrictSendOp"
	}
	return ""
}
func (v *XdrAnon_Operation_Body) XdrPointer() interface{} { return v }
func (v XdrAnon_Operation_Body) XdrValue() interface{} { return v }
func (v *XdrAnon_Operation_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Operation_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CREATE_ACCOUNT:
		XDR_CreateAccountOp(u.CreateAccountOp()).XdrMarshal(x, x.Sprintf("%screateAccountOp", name))
		return
	case PAYMENT:
		XDR_PaymentOp(u.PaymentOp()).XdrMarshal(x, x.Sprintf("%spaymentOp", name))
		return
	case PATH_PAYMENT_STRICT_RECEIVE:
		XDR_PathPaymentStrictReceiveOp(u.PathPaymentStrictReceiveOp()).XdrMarshal(x, x.Sprintf("%spathPaymentStrictReceiveOp", name))
		return
	case MANAGE_SELL_OFFER:
		XDR_ManageSellOfferOp(u.ManageSellOfferOp()).XdrMarshal(x, x.Sprintf("%smanageSellOfferOp", name))
		return
	case CREATE_PASSIVE_SELL_OFFER:
		XDR_CreatePassiveSellOfferOp(u.CreatePassiveSellOfferOp()).XdrMarshal(x, x.Sprintf("%screatePassiveSellOfferOp", name))
		return
	case SET_OPTIONS:
		XDR_SetOptionsOp(u.SetOptionsOp()).XdrMarshal(x, x.Sprintf("%ssetOptionsOp", name))
		return
	case CHANGE_TRUST:
		XDR_ChangeTrustOp(u.ChangeTrustOp()).XdrMarshal(x, x.Sprintf("%schangeTrustOp", name))
		return
	case ALLOW_TRUST:
		XDR_AllowTrustOp(u.AllowTrustOp()).XdrMarshal(x, x.Sprintf("%sallowTrustOp", name))
		return
	case ACCOUNT_MERGE:
		XDR_AccountID(u.Destination()).XdrMarshal(x, x.Sprintf("%sdestination", name))
		return
	case INFLATION:
		return
	case MANAGE_DATA:
		XDR_ManageDataOp(u.ManageDataOp()).XdrMarshal(x, x.Sprintf("%smanageDataOp", name))
		return
	case BUMP_SEQUENCE:
		XDR_BumpSequenceOp(u.BumpSequenceOp()).XdrMarshal(x, x.Sprintf("%sbumpSequenceOp", name))
		return
	case MANAGE_BUY_OFFER:
		XDR_ManageBuyOfferOp(u.ManageBuyOfferOp()).XdrMarshal(x, x.Sprintf("%smanageBuyOfferOp", name))
		return
	case PATH_PAYMENT_STRICT_SEND:
		XDR_PathPaymentStrictSendOp(u.PathPaymentStrictSendOp()).XdrMarshal(x, x.Sprintf("%spathPaymentStrictSendOp", name))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_Operation_Body", u.Type)
}
func XDR_XdrAnon_Operation_Body(v *XdrAnon_Operation_Body) *XdrAnon_Operation_Body { return v}
func (v *Operation) XdrPointer() interface{} { return v }
func (v Operation) XdrValue() interface{} { return v }
func (v *Operation) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Operation) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), _XdrPtr_AccountID{&v.SourceAccount})
	XDR_XdrAnon_Operation_Body(&v.Body).XdrMarshal(x, x.Sprintf("%sbody", name))
}
func XDR_Operation(v *Operation) *Operation { return v }
var _XdrNames_MemoType = map[int32]string{
	int32(MEMO_NONE): "MEMO_NONE",
	int32(MEMO_TEXT): "MEMO_TEXT",
	int32(MEMO_ID): "MEMO_ID",
	int32(MEMO_HASH): "MEMO_HASH",
	int32(MEMO_RETURN): "MEMO_RETURN",
}
var _XdrValues_MemoType = map[string]int32{
	"MEMO_NONE": int32(MEMO_NONE),
	"MEMO_TEXT": int32(MEMO_TEXT),
	"MEMO_ID": int32(MEMO_ID),
	"MEMO_HASH": int32(MEMO_HASH),
	"MEMO_RETURN": int32(MEMO_RETURN),
}
func (MemoType) XdrEnumNames() map[int32]string {
	return _XdrNames_MemoType
}
func (v MemoType) String() string {
	if s, ok := _XdrNames_MemoType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("MemoType#%d", v)
}
func (v *MemoType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MemoType[stok]; ok {
			*v = MemoType(val)
			return nil
		} else if stok == "MemoType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid MemoType.", stok))
	}
}
func (v MemoType) GetU32() uint32 { return uint32(v) }
func (v *MemoType) SetU32(n uint32) { *v = MemoType(n) }
func (v *MemoType) XdrPointer() interface{} { return v }
func (v MemoType) XdrValue() interface{} { return v }
func (v *MemoType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_MemoType(v *MemoType) *MemoType { return v }
func (u *Memo) Text() *string {
	switch u.Type {
	case MEMO_TEXT:
		if v, ok := u._u.(*string); ok {
			return v
		} else {
			var zero string
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Text accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Memo) Id() *Uint64 {
	switch u.Type {
	case MEMO_ID:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Id accessed when Type == %v", u.Type)
		return nil
	}
}
// the hash of what to pull from the content server
func (u *Memo) Hash() *Hash {
	switch u.Type {
	case MEMO_HASH:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Hash accessed when Type == %v", u.Type)
		return nil
	}
}
// the hash of the tx you are rejecting
func (u *Memo) RetHash() *Hash {
	switch u.Type {
	case MEMO_RETURN:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.RetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Memo) XdrValid() bool {
	switch u.Type {
	case MEMO_NONE,MEMO_TEXT,MEMO_ID,MEMO_HASH,MEMO_RETURN:
		return true
	}
	return false
}
func (u *Memo) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *Memo) XdrUnionTagName() string {
	return "Type"
}
func (u *Memo) XdrUnionBody() interface{} {
	switch u.Type {
	case MEMO_NONE:
		return nil
	case MEMO_TEXT:
		return u.Text()
	case MEMO_ID:
		return u.Id()
	case MEMO_HASH:
		return u.Hash()
	case MEMO_RETURN:
		return u.RetHash()
	}
	return nil
}
func (u *Memo) XdrUnionBodyName() string {
	switch u.Type {
	case MEMO_NONE:
		return ""
	case MEMO_TEXT:
		return "Text"
	case MEMO_ID:
		return "Id"
	case MEMO_HASH:
		return "Hash"
	case MEMO_RETURN:
		return "RetHash"
	}
	return ""
}
func (v *Memo) XdrPointer() interface{} { return v }
func (v Memo) XdrValue() interface{} { return v }
func (v *Memo) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Memo) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MemoType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case MEMO_NONE:
		return
	case MEMO_TEXT:
		x.Marshal(x.Sprintf("%stext", name), XdrString{u.Text(), 28})
		return
	case MEMO_ID:
		XDR_Uint64(u.Id()).XdrMarshal(x, x.Sprintf("%sid", name))
		return
	case MEMO_HASH:
		XDR_Hash(u.Hash()).XdrMarshal(x, x.Sprintf("%shash", name))
		return
	case MEMO_RETURN:
		XDR_Hash(u.RetHash()).XdrMarshal(x, x.Sprintf("%sretHash", name))
		return
	}
	XdrPanic("invalid Type (%v) in Memo", u.Type)
}
func XDR_Memo(v *Memo) *Memo { return v}
func (v *TimeBounds) XdrPointer() interface{} { return v }
func (v TimeBounds) XdrValue() interface{} { return v }
func (v *TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TimeBounds) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TimePoint(&v.MinTime).XdrMarshal(x, x.Sprintf("%sminTime", name))
	XDR_TimePoint(&v.MaxTime).XdrMarshal(x, x.Sprintf("%smaxTime", name))
}
func XDR_TimeBounds(v *TimeBounds) *TimeBounds { return v }
func (u XdrAnon_Transaction_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_Transaction_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_Transaction_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_Transaction_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_Transaction_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_Transaction_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_Transaction_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_Transaction_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Transaction_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_Transaction_Ext", u.V)
}
func XDR_XdrAnon_Transaction_Ext(v *XdrAnon_Transaction_Ext) *XdrAnon_Transaction_Ext { return v}
type _XdrPtr_TimeBounds struct {
	p **TimeBounds
}
type _ptrflag_TimeBounds _XdrPtr_TimeBounds
func (v _ptrflag_TimeBounds) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_TimeBounds) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("TimeBounds flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_TimeBounds) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_TimeBounds) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(TimeBounds)
		}
	default:
		XdrPanic("*TimeBounds present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_TimeBounds) XdrPointer() interface{} { return nil }
func (v _ptrflag_TimeBounds) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_TimeBounds) XdrBound() uint32 { return 1 }
func (v _XdrPtr_TimeBounds) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_TimeBounds) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(TimeBounds)
	}
}
func (v _XdrPtr_TimeBounds) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_TimeBounds(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_TimeBounds) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_TimeBounds(v))
	v.XdrMarshalValue(x, name)
}
func (v _XdrPtr_TimeBounds) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_TimeBounds) XdrValue() interface{} { return *v.p }
type _XdrVec_100_Operation []Operation
func (_XdrVec_100_Operation) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_100_Operation) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		XdrPanic("_XdrVec_100_Operation length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_100_Operation length %d exceeds max int", length)
	}
}
func (v _XdrVec_100_Operation) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_100_Operation) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Operation, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_100_Operation) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Operation(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_100_Operation) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 100 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_100_Operation) XdrPointer() interface{} { return (*[]Operation)(v) }
func (v _XdrVec_100_Operation) XdrValue() interface{} { return ([]Operation)(v) }
func (v *_XdrVec_100_Operation) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Transaction) XdrPointer() interface{} { return v }
func (v Transaction) XdrValue() interface{} { return v }
func (v *Transaction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Transaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.SourceAccount).XdrMarshal(x, x.Sprintf("%ssourceAccount", name))
	XDR_Uint32(&v.Fee).XdrMarshal(x, x.Sprintf("%sfee", name))
	XDR_SequenceNumber(&v.SeqNum).XdrMarshal(x, x.Sprintf("%sseqNum", name))
	x.Marshal(x.Sprintf("%stimeBounds", name), _XdrPtr_TimeBounds{&v.TimeBounds})
	XDR_Memo(&v.Memo).XdrMarshal(x, x.Sprintf("%smemo", name))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_100_Operation)(&v.Operations))
	XDR_XdrAnon_Transaction_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_Transaction(v *Transaction) *Transaction { return v }
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) Tx() *Transaction {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*Transaction); ok {
			return v
		} else {
			var zero Transaction
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionSignaturePayload_TaggedTransaction.Tx accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionBody() interface{} {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return u.Tx()
	}
	return nil
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return "Tx"
	}
	return ""
}
func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrPointer() interface{} { return v }
func (v XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		XDR_Transaction(u.Tx()).XdrMarshal(x, x.Sprintf("%stx", name))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_TransactionSignaturePayload_TaggedTransaction", u.Type)
}
func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrInitialize() {
	var zero EnvelopeType
	switch zero {
	case ENVELOPE_TYPE_TX:
	default:
		if v.Type == zero { v.Type = ENVELOPE_TYPE_TX }
	}
}
func XDR_XdrAnon_TransactionSignaturePayload_TaggedTransaction(v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) *XdrAnon_TransactionSignaturePayload_TaggedTransaction { return v}
func (v *TransactionSignaturePayload) XdrPointer() interface{} { return v }
func (v TransactionSignaturePayload) XdrValue() interface{} { return v }
func (v *TransactionSignaturePayload) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSignaturePayload) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(&v.NetworkId).XdrMarshal(x, x.Sprintf("%snetworkId", name))
	XDR_XdrAnon_TransactionSignaturePayload_TaggedTransaction(&v.TaggedTransaction).XdrMarshal(x, x.Sprintf("%staggedTransaction", name))
}
func XDR_TransactionSignaturePayload(v *TransactionSignaturePayload) *TransactionSignaturePayload { return v }
type _XdrVec_20_DecoratedSignature []DecoratedSignature
func (_XdrVec_20_DecoratedSignature) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_DecoratedSignature) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_DecoratedSignature length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_DecoratedSignature length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_DecoratedSignature) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_DecoratedSignature) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]DecoratedSignature, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_DecoratedSignature) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_DecoratedSignature(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_DecoratedSignature) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 20 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_20_DecoratedSignature) XdrPointer() interface{} { return (*[]DecoratedSignature)(v) }
func (v _XdrVec_20_DecoratedSignature) XdrValue() interface{} { return ([]DecoratedSignature)(v) }
func (v *_XdrVec_20_DecoratedSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionEnvelope) XdrPointer() interface{} { return v }
func (v TransactionEnvelope) XdrValue() interface{} { return v }
func (v *TransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Transaction(&v.Tx).XdrMarshal(x, x.Sprintf("%stx", name))
	x.Marshal(x.Sprintf("%ssignatures", name), (*_XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_TransactionEnvelope(v *TransactionEnvelope) *TransactionEnvelope { return v }
func (v *ClaimOfferAtom) XdrPointer() interface{} { return v }
func (v ClaimOfferAtom) XdrValue() interface{} { return v }
func (v *ClaimOfferAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimOfferAtom) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.SellerID).XdrMarshal(x, x.Sprintf("%ssellerID", name))
	XDR_Int64(&v.OfferID).XdrMarshal(x, x.Sprintf("%sofferID", name))
	XDR_Asset(&v.AssetSold).XdrMarshal(x, x.Sprintf("%sassetSold", name))
	XDR_Int64(&v.AmountSold).XdrMarshal(x, x.Sprintf("%samountSold", name))
	XDR_Asset(&v.AssetBought).XdrMarshal(x, x.Sprintf("%sassetBought", name))
	XDR_Int64(&v.AmountBought).XdrMarshal(x, x.Sprintf("%samountBought", name))
}
func XDR_ClaimOfferAtom(v *ClaimOfferAtom) *ClaimOfferAtom { return v }
var _XdrNames_CreateAccountResultCode = map[int32]string{
	int32(CREATE_ACCOUNT_SUCCESS): "CREATE_ACCOUNT_SUCCESS",
	int32(CREATE_ACCOUNT_MALFORMED): "CREATE_ACCOUNT_MALFORMED",
	int32(CREATE_ACCOUNT_UNDERFUNDED): "CREATE_ACCOUNT_UNDERFUNDED",
	int32(CREATE_ACCOUNT_LOW_RESERVE): "CREATE_ACCOUNT_LOW_RESERVE",
	int32(CREATE_ACCOUNT_ALREADY_EXIST): "CREATE_ACCOUNT_ALREADY_EXIST",
}
var _XdrValues_CreateAccountResultCode = map[string]int32{
	"CREATE_ACCOUNT_SUCCESS": int32(CREATE_ACCOUNT_SUCCESS),
	"CREATE_ACCOUNT_MALFORMED": int32(CREATE_ACCOUNT_MALFORMED),
	"CREATE_ACCOUNT_UNDERFUNDED": int32(CREATE_ACCOUNT_UNDERFUNDED),
	"CREATE_ACCOUNT_LOW_RESERVE": int32(CREATE_ACCOUNT_LOW_RESERVE),
	"CREATE_ACCOUNT_ALREADY_EXIST": int32(CREATE_ACCOUNT_ALREADY_EXIST),
}
func (CreateAccountResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_CreateAccountResultCode
}
func (v CreateAccountResultCode) String() string {
	if s, ok := _XdrNames_CreateAccountResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CreateAccountResultCode#%d", v)
}
func (v *CreateAccountResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CreateAccountResultCode[stok]; ok {
			*v = CreateAccountResultCode(val)
			return nil
		} else if stok == "CreateAccountResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CreateAccountResultCode.", stok))
	}
}
func (v CreateAccountResultCode) GetU32() uint32 { return uint32(v) }
func (v *CreateAccountResultCode) SetU32(n uint32) { *v = CreateAccountResultCode(n) }
func (v *CreateAccountResultCode) XdrPointer() interface{} { return v }
func (v CreateAccountResultCode) XdrValue() interface{} { return v }
func (v *CreateAccountResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_CreateAccountResultCode(v *CreateAccountResultCode) *CreateAccountResultCode { return v }
var _XdrComments_CreateAccountResultCode = map[int32]string {
	int32(CREATE_ACCOUNT_SUCCESS): "account was created",
	int32(CREATE_ACCOUNT_MALFORMED): "invalid destination",
	int32(CREATE_ACCOUNT_UNDERFUNDED): "not enough funds in source account",
	int32(CREATE_ACCOUNT_LOW_RESERVE): "would create an account below the min reserve",
	int32(CREATE_ACCOUNT_ALREADY_EXIST): "account already exists",
}
func (e CreateAccountResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_CreateAccountResultCode
}
func (u CreateAccountResult) XdrValid() bool {
	return true
}
func (u *CreateAccountResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *CreateAccountResult) XdrUnionTagName() string {
	return "Code"
}
func (u *CreateAccountResult) XdrUnionBody() interface{} {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *CreateAccountResult) XdrUnionBodyName() string {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *CreateAccountResult) XdrPointer() interface{} { return v }
func (v CreateAccountResult) XdrValue() interface{} { return v }
func (v *CreateAccountResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CreateAccountResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CreateAccountResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return
	default:
		return
	}
}
func XDR_CreateAccountResult(v *CreateAccountResult) *CreateAccountResult { return v}
var _XdrNames_PaymentResultCode = map[int32]string{
	int32(PAYMENT_SUCCESS): "PAYMENT_SUCCESS",
	int32(PAYMENT_MALFORMED): "PAYMENT_MALFORMED",
	int32(PAYMENT_UNDERFUNDED): "PAYMENT_UNDERFUNDED",
	int32(PAYMENT_SRC_NO_TRUST): "PAYMENT_SRC_NO_TRUST",
	int32(PAYMENT_SRC_NOT_AUTHORIZED): "PAYMENT_SRC_NOT_AUTHORIZED",
	int32(PAYMENT_NO_DESTINATION): "PAYMENT_NO_DESTINATION",
	int32(PAYMENT_NO_TRUST): "PAYMENT_NO_TRUST",
	int32(PAYMENT_NOT_AUTHORIZED): "PAYMENT_NOT_AUTHORIZED",
	int32(PAYMENT_LINE_FULL): "PAYMENT_LINE_FULL",
	int32(PAYMENT_NO_ISSUER): "PAYMENT_NO_ISSUER",
}
var _XdrValues_PaymentResultCode = map[string]int32{
	"PAYMENT_SUCCESS": int32(PAYMENT_SUCCESS),
	"PAYMENT_MALFORMED": int32(PAYMENT_MALFORMED),
	"PAYMENT_UNDERFUNDED": int32(PAYMENT_UNDERFUNDED),
	"PAYMENT_SRC_NO_TRUST": int32(PAYMENT_SRC_NO_TRUST),
	"PAYMENT_SRC_NOT_AUTHORIZED": int32(PAYMENT_SRC_NOT_AUTHORIZED),
	"PAYMENT_NO_DESTINATION": int32(PAYMENT_NO_DESTINATION),
	"PAYMENT_NO_TRUST": int32(PAYMENT_NO_TRUST),
	"PAYMENT_NOT_AUTHORIZED": int32(PAYMENT_NOT_AUTHORIZED),
	"PAYMENT_LINE_FULL": int32(PAYMENT_LINE_FULL),
	"PAYMENT_NO_ISSUER": int32(PAYMENT_NO_ISSUER),
}
func (PaymentResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PaymentResultCode
}
func (v PaymentResultCode) String() string {
	if s, ok := _XdrNames_PaymentResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PaymentResultCode#%d", v)
}
func (v *PaymentResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PaymentResultCode[stok]; ok {
			*v = PaymentResultCode(val)
			return nil
		} else if stok == "PaymentResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PaymentResultCode.", stok))
	}
}
func (v PaymentResultCode) GetU32() uint32 { return uint32(v) }
func (v *PaymentResultCode) SetU32(n uint32) { *v = PaymentResultCode(n) }
func (v *PaymentResultCode) XdrPointer() interface{} { return v }
func (v PaymentResultCode) XdrValue() interface{} { return v }
func (v *PaymentResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_PaymentResultCode(v *PaymentResultCode) *PaymentResultCode { return v }
var _XdrComments_PaymentResultCode = map[int32]string {
	int32(PAYMENT_SUCCESS): "payment successfuly completed",
	int32(PAYMENT_MALFORMED): "bad input",
	int32(PAYMENT_UNDERFUNDED): "not enough funds in source account",
	int32(PAYMENT_SRC_NO_TRUST): "no trust line on source account",
	int32(PAYMENT_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PAYMENT_NO_DESTINATION): "destination account does not exist",
	int32(PAYMENT_NO_TRUST): "destination missing a trust line for asset",
	int32(PAYMENT_NOT_AUTHORIZED): "destination not authorized to hold asset",
	int32(PAYMENT_LINE_FULL): "destination would go above their limit",
	int32(PAYMENT_NO_ISSUER): "missing issuer on asset",
}
func (e PaymentResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PaymentResultCode
}
func (u PaymentResult) XdrValid() bool {
	return true
}
func (u *PaymentResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *PaymentResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PaymentResult) XdrUnionBody() interface{} {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *PaymentResult) XdrUnionBodyName() string {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *PaymentResult) XdrPointer() interface{} { return v }
func (v PaymentResult) XdrValue() interface{} { return v }
func (v *PaymentResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PaymentResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PaymentResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PAYMENT_SUCCESS:
		return
	default:
		return
	}
}
func XDR_PaymentResult(v *PaymentResult) *PaymentResult { return v}
var _XdrNames_PathPaymentStrictReceiveResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS): "PATH_PAYMENT_STRICT_RECEIVE_SUCCESS",
	int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED): "PATH_PAYMENT_STRICT_RECEIVE_MALFORMED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED): "PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST): "PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION): "PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST): "PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL): "PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER): "PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER",
	int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS): "PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF): "PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX): "PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX",
}
var _XdrValues_PathPaymentStrictReceiveResultCode = map[string]int32{
	"PATH_PAYMENT_STRICT_RECEIVE_SUCCESS": int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS),
	"PATH_PAYMENT_STRICT_RECEIVE_MALFORMED": int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED),
	"PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED": int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED),
	"PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST": int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST),
	"PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION": int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST": int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST),
	"PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL": int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER": int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER),
	"PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS": int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS),
	"PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF": int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF),
	"PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX": int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX),
}
func (PathPaymentStrictReceiveResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PathPaymentStrictReceiveResultCode
}
func (v PathPaymentStrictReceiveResultCode) String() string {
	if s, ok := _XdrNames_PathPaymentStrictReceiveResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PathPaymentStrictReceiveResultCode#%d", v)
}
func (v *PathPaymentStrictReceiveResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PathPaymentStrictReceiveResultCode[stok]; ok {
			*v = PathPaymentStrictReceiveResultCode(val)
			return nil
		} else if stok == "PathPaymentStrictReceiveResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PathPaymentStrictReceiveResultCode.", stok))
	}
}
func (v PathPaymentStrictReceiveResultCode) GetU32() uint32 { return uint32(v) }
func (v *PathPaymentStrictReceiveResultCode) SetU32(n uint32) { *v = PathPaymentStrictReceiveResultCode(n) }
func (v *PathPaymentStrictReceiveResultCode) XdrPointer() interface{} { return v }
func (v PathPaymentStrictReceiveResultCode) XdrValue() interface{} { return v }
func (v *PathPaymentStrictReceiveResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_PathPaymentStrictReceiveResultCode(v *PathPaymentStrictReceiveResultCode) *PathPaymentStrictReceiveResultCode { return v }
var _XdrComments_PathPaymentStrictReceiveResultCode = map[int32]string {
	int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS): "success",
	int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED): "bad input",
	int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED): "not enough funds in source account",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST): "no trust line on source account",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION): "destination account does not exist",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST): "dest missing a trust line for asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED): "dest not authorized to hold asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL): "dest would go above their limit",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER): "missing issuer on one asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS): "not enough offers to satisfy path",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF): "would cross one of its own offers",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX): "could not satisfy sendmax",
}
func (e PathPaymentStrictReceiveResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PathPaymentStrictReceiveResultCode
}
func (v *SimplePaymentResult) XdrPointer() interface{} { return v }
func (v SimplePaymentResult) XdrValue() interface{} { return v }
func (v *SimplePaymentResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SimplePaymentResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.Destination).XdrMarshal(x, x.Sprintf("%sdestination", name))
	XDR_Asset(&v.Asset).XdrMarshal(x, x.Sprintf("%sasset", name))
	XDR_Int64(&v.Amount).XdrMarshal(x, x.Sprintf("%samount", name))
}
func XDR_SimplePaymentResult(v *SimplePaymentResult) *SimplePaymentResult { return v }
type _XdrVec_unbounded_ClaimOfferAtom []ClaimOfferAtom
func (_XdrVec_unbounded_ClaimOfferAtom) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_ClaimOfferAtom) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_ClaimOfferAtom length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_ClaimOfferAtom length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_ClaimOfferAtom) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_ClaimOfferAtom) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ClaimOfferAtom, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_ClaimOfferAtom) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_ClaimOfferAtom(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_ClaimOfferAtom) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_ClaimOfferAtom) XdrPointer() interface{} { return (*[]ClaimOfferAtom)(v) }
func (v _XdrVec_unbounded_ClaimOfferAtom) XdrValue() interface{} { return ([]ClaimOfferAtom)(v) }
func (v *_XdrVec_unbounded_ClaimOfferAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrPointer() interface{} { return v }
func (v XdrAnon_PathPaymentStrictReceiveResult_Success) XdrValue() interface{} { return v }
func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffers", name), (*_XdrVec_unbounded_ClaimOfferAtom)(&v.Offers))
	XDR_SimplePaymentResult(&v.Last).XdrMarshal(x, x.Sprintf("%slast", name))
}
func XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(v *XdrAnon_PathPaymentStrictReceiveResult_Success) *XdrAnon_PathPaymentStrictReceiveResult_Success { return v }
func (u *PathPaymentStrictReceiveResult) Success() *XdrAnon_PathPaymentStrictReceiveResult_Success {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		if v, ok := u._u.(*XdrAnon_PathPaymentStrictReceiveResult_Success); ok {
			return v
		} else {
			var zero XdrAnon_PathPaymentStrictReceiveResult_Success
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictReceiveResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
// the asset that caused the error
func (u *PathPaymentStrictReceiveResult) NoIssuer() *Asset {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictReceiveResult.NoIssuer accessed when Code == %v", u.Code)
		return nil
	}
}
func (u PathPaymentStrictReceiveResult) XdrValid() bool {
	return true
}
func (u *PathPaymentStrictReceiveResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *PathPaymentStrictReceiveResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PathPaymentStrictReceiveResult) XdrUnionBody() interface{} {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		return u.Success()
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		return u.NoIssuer()
	default:
		return nil
	}
}
func (u *PathPaymentStrictReceiveResult) XdrUnionBodyName() string {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		return "Success"
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		return "NoIssuer"
	default:
		return ""
	}
}
func (v *PathPaymentStrictReceiveResult) XdrPointer() interface{} { return v }
func (v PathPaymentStrictReceiveResult) XdrValue() interface{} { return v }
func (v *PathPaymentStrictReceiveResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PathPaymentStrictReceiveResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PathPaymentStrictReceiveResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(u.Success()).XdrMarshal(x, x.Sprintf("%ssuccess", name))
		return
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		XDR_Asset(u.NoIssuer()).XdrMarshal(x, x.Sprintf("%snoIssuer", name))
		return
	default:
		return
	}
}
func XDR_PathPaymentStrictReceiveResult(v *PathPaymentStrictReceiveResult) *PathPaymentStrictReceiveResult { return v}
var _XdrNames_PathPaymentStrictSendResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_SEND_SUCCESS): "PATH_PAYMENT_STRICT_SEND_SUCCESS",
	int32(PATH_PAYMENT_STRICT_SEND_MALFORMED): "PATH_PAYMENT_STRICT_SEND_MALFORMED",
	int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED): "PATH_PAYMENT_STRICT_SEND_UNDERFUNDED",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST): "PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION): "PATH_PAYMENT_STRICT_SEND_NO_DESTINATION",
	int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST): "PATH_PAYMENT_STRICT_SEND_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL): "PATH_PAYMENT_STRICT_SEND_LINE_FULL",
	int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER): "PATH_PAYMENT_STRICT_SEND_NO_ISSUER",
	int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS): "PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS",
	int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF): "PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF",
	int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN): "PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN",
}
var _XdrValues_PathPaymentStrictSendResultCode = map[string]int32{
	"PATH_PAYMENT_STRICT_SEND_SUCCESS": int32(PATH_PAYMENT_STRICT_SEND_SUCCESS),
	"PATH_PAYMENT_STRICT_SEND_MALFORMED": int32(PATH_PAYMENT_STRICT_SEND_MALFORMED),
	"PATH_PAYMENT_STRICT_SEND_UNDERFUNDED": int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED),
	"PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST": int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST),
	"PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_SEND_NO_DESTINATION": int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION),
	"PATH_PAYMENT_STRICT_SEND_NO_TRUST": int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST),
	"PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_SEND_LINE_FULL": int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL),
	"PATH_PAYMENT_STRICT_SEND_NO_ISSUER": int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER),
	"PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS": int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS),
	"PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF": int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF),
	"PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN": int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN),
}
func (PathPaymentStrictSendResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PathPaymentStrictSendResultCode
}
func (v PathPaymentStrictSendResultCode) String() string {
	if s, ok := _XdrNames_PathPaymentStrictSendResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PathPaymentStrictSendResultCode#%d", v)
}
func (v *PathPaymentStrictSendResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PathPaymentStrictSendResultCode[stok]; ok {
			*v = PathPaymentStrictSendResultCode(val)
			return nil
		} else if stok == "PathPaymentStrictSendResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PathPaymentStrictSendResultCode.", stok))
	}
}
func (v PathPaymentStrictSendResultCode) GetU32() uint32 { return uint32(v) }
func (v *PathPaymentStrictSendResultCode) SetU32(n uint32) { *v = PathPaymentStrictSendResultCode(n) }
func (v *PathPaymentStrictSendResultCode) XdrPointer() interface{} { return v }
func (v PathPaymentStrictSendResultCode) XdrValue() interface{} { return v }
func (v *PathPaymentStrictSendResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_PathPaymentStrictSendResultCode(v *PathPaymentStrictSendResultCode) *PathPaymentStrictSendResultCode { return v }
var _XdrComments_PathPaymentStrictSendResultCode = map[int32]string {
	int32(PATH_PAYMENT_STRICT_SEND_SUCCESS): "success",
	int32(PATH_PAYMENT_STRICT_SEND_MALFORMED): "bad input",
	int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED): "not enough funds in source account",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST): "no trust line on source account",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION): "destination account does not exist",
	int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST): "dest missing a trust line for asset",
	int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED): "dest not authorized to hold asset",
	int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL): "dest would go above their limit",
	int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER): "missing issuer on one asset",
	int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS): "not enough offers to satisfy path",
	int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF): "would cross one of its own offers",
	int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN): "could not satisfy destMin",
}
func (e PathPaymentStrictSendResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PathPaymentStrictSendResultCode
}
func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrPointer() interface{} { return v }
func (v XdrAnon_PathPaymentStrictSendResult_Success) XdrValue() interface{} { return v }
func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffers", name), (*_XdrVec_unbounded_ClaimOfferAtom)(&v.Offers))
	XDR_SimplePaymentResult(&v.Last).XdrMarshal(x, x.Sprintf("%slast", name))
}
func XDR_XdrAnon_PathPaymentStrictSendResult_Success(v *XdrAnon_PathPaymentStrictSendResult_Success) *XdrAnon_PathPaymentStrictSendResult_Success { return v }
func (u *PathPaymentStrictSendResult) Success() *XdrAnon_PathPaymentStrictSendResult_Success {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		if v, ok := u._u.(*XdrAnon_PathPaymentStrictSendResult_Success); ok {
			return v
		} else {
			var zero XdrAnon_PathPaymentStrictSendResult_Success
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictSendResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
// the asset that caused the error
func (u *PathPaymentStrictSendResult) NoIssuer() *Asset {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictSendResult.NoIssuer accessed when Code == %v", u.Code)
		return nil
	}
}
func (u PathPaymentStrictSendResult) XdrValid() bool {
	return true
}
func (u *PathPaymentStrictSendResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *PathPaymentStrictSendResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PathPaymentStrictSendResult) XdrUnionBody() interface{} {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		return u.Success()
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		return u.NoIssuer()
	default:
		return nil
	}
}
func (u *PathPaymentStrictSendResult) XdrUnionBodyName() string {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		return "Success"
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		return "NoIssuer"
	default:
		return ""
	}
}
func (v *PathPaymentStrictSendResult) XdrPointer() interface{} { return v }
func (v PathPaymentStrictSendResult) XdrValue() interface{} { return v }
func (v *PathPaymentStrictSendResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PathPaymentStrictSendResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PathPaymentStrictSendResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		XDR_XdrAnon_PathPaymentStrictSendResult_Success(u.Success()).XdrMarshal(x, x.Sprintf("%ssuccess", name))
		return
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		XDR_Asset(u.NoIssuer()).XdrMarshal(x, x.Sprintf("%snoIssuer", name))
		return
	default:
		return
	}
}
func XDR_PathPaymentStrictSendResult(v *PathPaymentStrictSendResult) *PathPaymentStrictSendResult { return v}
var _XdrNames_ManageSellOfferResultCode = map[int32]string{
	int32(MANAGE_SELL_OFFER_SUCCESS): "MANAGE_SELL_OFFER_SUCCESS",
	int32(MANAGE_SELL_OFFER_MALFORMED): "MANAGE_SELL_OFFER_MALFORMED",
	int32(MANAGE_SELL_OFFER_SELL_NO_TRUST): "MANAGE_SELL_OFFER_SELL_NO_TRUST",
	int32(MANAGE_SELL_OFFER_BUY_NO_TRUST): "MANAGE_SELL_OFFER_BUY_NO_TRUST",
	int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): "MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED",
	int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED): "MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED",
	int32(MANAGE_SELL_OFFER_LINE_FULL): "MANAGE_SELL_OFFER_LINE_FULL",
	int32(MANAGE_SELL_OFFER_UNDERFUNDED): "MANAGE_SELL_OFFER_UNDERFUNDED",
	int32(MANAGE_SELL_OFFER_CROSS_SELF): "MANAGE_SELL_OFFER_CROSS_SELF",
	int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER): "MANAGE_SELL_OFFER_SELL_NO_ISSUER",
	int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER): "MANAGE_SELL_OFFER_BUY_NO_ISSUER",
	int32(MANAGE_SELL_OFFER_NOT_FOUND): "MANAGE_SELL_OFFER_NOT_FOUND",
	int32(MANAGE_SELL_OFFER_LOW_RESERVE): "MANAGE_SELL_OFFER_LOW_RESERVE",
}
var _XdrValues_ManageSellOfferResultCode = map[string]int32{
	"MANAGE_SELL_OFFER_SUCCESS": int32(MANAGE_SELL_OFFER_SUCCESS),
	"MANAGE_SELL_OFFER_MALFORMED": int32(MANAGE_SELL_OFFER_MALFORMED),
	"MANAGE_SELL_OFFER_SELL_NO_TRUST": int32(MANAGE_SELL_OFFER_SELL_NO_TRUST),
	"MANAGE_SELL_OFFER_BUY_NO_TRUST": int32(MANAGE_SELL_OFFER_BUY_NO_TRUST),
	"MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED": int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED),
	"MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED": int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED),
	"MANAGE_SELL_OFFER_LINE_FULL": int32(MANAGE_SELL_OFFER_LINE_FULL),
	"MANAGE_SELL_OFFER_UNDERFUNDED": int32(MANAGE_SELL_OFFER_UNDERFUNDED),
	"MANAGE_SELL_OFFER_CROSS_SELF": int32(MANAGE_SELL_OFFER_CROSS_SELF),
	"MANAGE_SELL_OFFER_SELL_NO_ISSUER": int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER),
	"MANAGE_SELL_OFFER_BUY_NO_ISSUER": int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER),
	"MANAGE_SELL_OFFER_NOT_FOUND": int32(MANAGE_SELL_OFFER_NOT_FOUND),
	"MANAGE_SELL_OFFER_LOW_RESERVE": int32(MANAGE_SELL_OFFER_LOW_RESERVE),
}
func (ManageSellOfferResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageSellOfferResultCode
}
func (v ManageSellOfferResultCode) String() string {
	if s, ok := _XdrNames_ManageSellOfferResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageSellOfferResultCode#%d", v)
}
func (v *ManageSellOfferResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageSellOfferResultCode[stok]; ok {
			*v = ManageSellOfferResultCode(val)
			return nil
		} else if stok == "ManageSellOfferResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageSellOfferResultCode.", stok))
	}
}
func (v ManageSellOfferResultCode) GetU32() uint32 { return uint32(v) }
func (v *ManageSellOfferResultCode) SetU32(n uint32) { *v = ManageSellOfferResultCode(n) }
func (v *ManageSellOfferResultCode) XdrPointer() interface{} { return v }
func (v ManageSellOfferResultCode) XdrValue() interface{} { return v }
func (v *ManageSellOfferResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_ManageSellOfferResultCode(v *ManageSellOfferResultCode) *ManageSellOfferResultCode { return v }
var _XdrComments_ManageSellOfferResultCode = map[int32]string {
	int32(MANAGE_SELL_OFFER_SUCCESS): "codes considered as \"success\" for the operation",
	int32(MANAGE_SELL_OFFER_MALFORMED): "generated offer would be invalid",
	int32(MANAGE_SELL_OFFER_SELL_NO_TRUST): "no trust line for what we're selling",
	int32(MANAGE_SELL_OFFER_BUY_NO_TRUST): "no trust line for what we're buying",
	int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): "not authorized to sell",
	int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED): "not authorized to buy",
	int32(MANAGE_SELL_OFFER_LINE_FULL): "can't receive more of what it's buying",
	int32(MANAGE_SELL_OFFER_UNDERFUNDED): "doesn't hold what it's trying to sell",
	int32(MANAGE_SELL_OFFER_CROSS_SELF): "would cross an offer from the same user",
	int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER): "no issuer for what we're selling",
	int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER): "no issuer for what we're buying",
	int32(MANAGE_SELL_OFFER_NOT_FOUND): "offerID does not match an existing offer",
	int32(MANAGE_SELL_OFFER_LOW_RESERVE): "not enough funds to create a new Offer",
}
func (e ManageSellOfferResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageSellOfferResultCode
}
var _XdrNames_ManageOfferEffect = map[int32]string{
	int32(MANAGE_OFFER_CREATED): "MANAGE_OFFER_CREATED",
	int32(MANAGE_OFFER_UPDATED): "MANAGE_OFFER_UPDATED",
	int32(MANAGE_OFFER_DELETED): "MANAGE_OFFER_DELETED",
}
var _XdrValues_ManageOfferEffect = map[string]int32{
	"MANAGE_OFFER_CREATED": int32(MANAGE_OFFER_CREATED),
	"MANAGE_OFFER_UPDATED": int32(MANAGE_OFFER_UPDATED),
	"MANAGE_OFFER_DELETED": int32(MANAGE_OFFER_DELETED),
}
func (ManageOfferEffect) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageOfferEffect
}
func (v ManageOfferEffect) String() string {
	if s, ok := _XdrNames_ManageOfferEffect[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageOfferEffect#%d", v)
}
func (v *ManageOfferEffect) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageOfferEffect[stok]; ok {
			*v = ManageOfferEffect(val)
			return nil
		} else if stok == "ManageOfferEffect" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageOfferEffect.", stok))
	}
}
func (v ManageOfferEffect) GetU32() uint32 { return uint32(v) }
func (v *ManageOfferEffect) SetU32(n uint32) { *v = ManageOfferEffect(n) }
func (v *ManageOfferEffect) XdrPointer() interface{} { return v }
func (v ManageOfferEffect) XdrValue() interface{} { return v }
func (v *ManageOfferEffect) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_ManageOfferEffect(v *ManageOfferEffect) *ManageOfferEffect { return v }
func (u *XdrAnon_ManageOfferSuccessResult_Offer) Offer() *OfferEntry {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ManageOfferSuccessResult_Offer.Offer accessed when Effect == %v", u.Effect)
		return nil
	}
}
func (u XdrAnon_ManageOfferSuccessResult_Offer) XdrValid() bool {
	return true
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionTag() interface{} {
	return &u.Effect
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionTagName() string {
	return "Effect"
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionBody() interface{} {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return u.Offer()
	default:
		return nil
	}
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionBodyName() string {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return "Offer"
	default:
		return ""
	}
}
func (v *XdrAnon_ManageOfferSuccessResult_Offer) XdrPointer() interface{} { return v }
func (v XdrAnon_ManageOfferSuccessResult_Offer) XdrValue() interface{} { return v }
func (v *XdrAnon_ManageOfferSuccessResult_Offer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageOfferEffect(&u.Effect).XdrMarshal(x, x.Sprintf("%seffect", name))
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		XDR_OfferEntry(u.Offer()).XdrMarshal(x, x.Sprintf("%soffer", name))
		return
	default:
		return
	}
}
func XDR_XdrAnon_ManageOfferSuccessResult_Offer(v *XdrAnon_ManageOfferSuccessResult_Offer) *XdrAnon_ManageOfferSuccessResult_Offer { return v}
func (v *ManageOfferSuccessResult) XdrPointer() interface{} { return v }
func (v ManageOfferSuccessResult) XdrValue() interface{} { return v }
func (v *ManageOfferSuccessResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageOfferSuccessResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffersClaimed", name), (*_XdrVec_unbounded_ClaimOfferAtom)(&v.OffersClaimed))
	XDR_XdrAnon_ManageOfferSuccessResult_Offer(&v.Offer).XdrMarshal(x, x.Sprintf("%soffer", name))
}
func XDR_ManageOfferSuccessResult(v *ManageOfferSuccessResult) *ManageOfferSuccessResult { return v }
func (u *ManageSellOfferResult) Success() *ManageOfferSuccessResult {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		if v, ok := u._u.(*ManageOfferSuccessResult); ok {
			return v
		} else {
			var zero ManageOfferSuccessResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ManageSellOfferResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u ManageSellOfferResult) XdrValid() bool {
	return true
}
func (u *ManageSellOfferResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *ManageSellOfferResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageSellOfferResult) XdrUnionBody() interface{} {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		return u.Success()
	default:
		return nil
	}
}
func (u *ManageSellOfferResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		return "Success"
	default:
		return ""
	}
}
func (v *ManageSellOfferResult) XdrPointer() interface{} { return v }
func (v ManageSellOfferResult) XdrValue() interface{} { return v }
func (v *ManageSellOfferResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageSellOfferResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageSellOfferResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		XDR_ManageOfferSuccessResult(u.Success()).XdrMarshal(x, x.Sprintf("%ssuccess", name))
		return
	default:
		return
	}
}
func XDR_ManageSellOfferResult(v *ManageSellOfferResult) *ManageSellOfferResult { return v}
var _XdrNames_ManageBuyOfferResultCode = map[int32]string{
	int32(MANAGE_BUY_OFFER_SUCCESS): "MANAGE_BUY_OFFER_SUCCESS",
	int32(MANAGE_BUY_OFFER_MALFORMED): "MANAGE_BUY_OFFER_MALFORMED",
	int32(MANAGE_BUY_OFFER_SELL_NO_TRUST): "MANAGE_BUY_OFFER_SELL_NO_TRUST",
	int32(MANAGE_BUY_OFFER_BUY_NO_TRUST): "MANAGE_BUY_OFFER_BUY_NO_TRUST",
	int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): "MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED",
	int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED): "MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED",
	int32(MANAGE_BUY_OFFER_LINE_FULL): "MANAGE_BUY_OFFER_LINE_FULL",
	int32(MANAGE_BUY_OFFER_UNDERFUNDED): "MANAGE_BUY_OFFER_UNDERFUNDED",
	int32(MANAGE_BUY_OFFER_CROSS_SELF): "MANAGE_BUY_OFFER_CROSS_SELF",
	int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER): "MANAGE_BUY_OFFER_SELL_NO_ISSUER",
	int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER): "MANAGE_BUY_OFFER_BUY_NO_ISSUER",
	int32(MANAGE_BUY_OFFER_NOT_FOUND): "MANAGE_BUY_OFFER_NOT_FOUND",
	int32(MANAGE_BUY_OFFER_LOW_RESERVE): "MANAGE_BUY_OFFER_LOW_RESERVE",
}
var _XdrValues_ManageBuyOfferResultCode = map[string]int32{
	"MANAGE_BUY_OFFER_SUCCESS": int32(MANAGE_BUY_OFFER_SUCCESS),
	"MANAGE_BUY_OFFER_MALFORMED": int32(MANAGE_BUY_OFFER_MALFORMED),
	"MANAGE_BUY_OFFER_SELL_NO_TRUST": int32(MANAGE_BUY_OFFER_SELL_NO_TRUST),
	"MANAGE_BUY_OFFER_BUY_NO_TRUST": int32(MANAGE_BUY_OFFER_BUY_NO_TRUST),
	"MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED": int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED),
	"MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED": int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED),
	"MANAGE_BUY_OFFER_LINE_FULL": int32(MANAGE_BUY_OFFER_LINE_FULL),
	"MANAGE_BUY_OFFER_UNDERFUNDED": int32(MANAGE_BUY_OFFER_UNDERFUNDED),
	"MANAGE_BUY_OFFER_CROSS_SELF": int32(MANAGE_BUY_OFFER_CROSS_SELF),
	"MANAGE_BUY_OFFER_SELL_NO_ISSUER": int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER),
	"MANAGE_BUY_OFFER_BUY_NO_ISSUER": int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER),
	"MANAGE_BUY_OFFER_NOT_FOUND": int32(MANAGE_BUY_OFFER_NOT_FOUND),
	"MANAGE_BUY_OFFER_LOW_RESERVE": int32(MANAGE_BUY_OFFER_LOW_RESERVE),
}
func (ManageBuyOfferResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageBuyOfferResultCode
}
func (v ManageBuyOfferResultCode) String() string {
	if s, ok := _XdrNames_ManageBuyOfferResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageBuyOfferResultCode#%d", v)
}
func (v *ManageBuyOfferResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageBuyOfferResultCode[stok]; ok {
			*v = ManageBuyOfferResultCode(val)
			return nil
		} else if stok == "ManageBuyOfferResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageBuyOfferResultCode.", stok))
	}
}
func (v ManageBuyOfferResultCode) GetU32() uint32 { return uint32(v) }
func (v *ManageBuyOfferResultCode) SetU32(n uint32) { *v = ManageBuyOfferResultCode(n) }
func (v *ManageBuyOfferResultCode) XdrPointer() interface{} { return v }
func (v ManageBuyOfferResultCode) XdrValue() interface{} { return v }
func (v *ManageBuyOfferResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_ManageBuyOfferResultCode(v *ManageBuyOfferResultCode) *ManageBuyOfferResultCode { return v }
var _XdrComments_ManageBuyOfferResultCode = map[int32]string {
	int32(MANAGE_BUY_OFFER_SUCCESS): "codes considered as \"success\" for the operation",
	int32(MANAGE_BUY_OFFER_MALFORMED): "generated offer would be invalid",
	int32(MANAGE_BUY_OFFER_SELL_NO_TRUST): "no trust line for what we're selling",
	int32(MANAGE_BUY_OFFER_BUY_NO_TRUST): "no trust line for what we're buying",
	int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): "not authorized to sell",
	int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED): "not authorized to buy",
	int32(MANAGE_BUY_OFFER_LINE_FULL): "can't receive more of what it's buying",
	int32(MANAGE_BUY_OFFER_UNDERFUNDED): "doesn't hold what it's trying to sell",
	int32(MANAGE_BUY_OFFER_CROSS_SELF): "would cross an offer from the same user",
	int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER): "no issuer for what we're selling",
	int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER): "no issuer for what we're buying",
	int32(MANAGE_BUY_OFFER_NOT_FOUND): "offerID does not match an existing offer",
	int32(MANAGE_BUY_OFFER_LOW_RESERVE): "not enough funds to create a new Offer",
}
func (e ManageBuyOfferResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageBuyOfferResultCode
}
func (u *ManageBuyOfferResult) Success() *ManageOfferSuccessResult {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		if v, ok := u._u.(*ManageOfferSuccessResult); ok {
			return v
		} else {
			var zero ManageOfferSuccessResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ManageBuyOfferResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u ManageBuyOfferResult) XdrValid() bool {
	return true
}
func (u *ManageBuyOfferResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *ManageBuyOfferResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageBuyOfferResult) XdrUnionBody() interface{} {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		return u.Success()
	default:
		return nil
	}
}
func (u *ManageBuyOfferResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		return "Success"
	default:
		return ""
	}
}
func (v *ManageBuyOfferResult) XdrPointer() interface{} { return v }
func (v ManageBuyOfferResult) XdrValue() interface{} { return v }
func (v *ManageBuyOfferResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageBuyOfferResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageBuyOfferResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		XDR_ManageOfferSuccessResult(u.Success()).XdrMarshal(x, x.Sprintf("%ssuccess", name))
		return
	default:
		return
	}
}
func XDR_ManageBuyOfferResult(v *ManageBuyOfferResult) *ManageBuyOfferResult { return v}
var _XdrNames_SetOptionsResultCode = map[int32]string{
	int32(SET_OPTIONS_SUCCESS): "SET_OPTIONS_SUCCESS",
	int32(SET_OPTIONS_LOW_RESERVE): "SET_OPTIONS_LOW_RESERVE",
	int32(SET_OPTIONS_TOO_MANY_SIGNERS): "SET_OPTIONS_TOO_MANY_SIGNERS",
	int32(SET_OPTIONS_BAD_FLAGS): "SET_OPTIONS_BAD_FLAGS",
	int32(SET_OPTIONS_INVALID_INFLATION): "SET_OPTIONS_INVALID_INFLATION",
	int32(SET_OPTIONS_CANT_CHANGE): "SET_OPTIONS_CANT_CHANGE",
	int32(SET_OPTIONS_UNKNOWN_FLAG): "SET_OPTIONS_UNKNOWN_FLAG",
	int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE): "SET_OPTIONS_THRESHOLD_OUT_OF_RANGE",
	int32(SET_OPTIONS_BAD_SIGNER): "SET_OPTIONS_BAD_SIGNER",
	int32(SET_OPTIONS_INVALID_HOME_DOMAIN): "SET_OPTIONS_INVALID_HOME_DOMAIN",
}
var _XdrValues_SetOptionsResultCode = map[string]int32{
	"SET_OPTIONS_SUCCESS": int32(SET_OPTIONS_SUCCESS),
	"SET_OPTIONS_LOW_RESERVE": int32(SET_OPTIONS_LOW_RESERVE),
	"SET_OPTIONS_TOO_MANY_SIGNERS": int32(SET_OPTIONS_TOO_MANY_SIGNERS),
	"SET_OPTIONS_BAD_FLAGS": int32(SET_OPTIONS_BAD_FLAGS),
	"SET_OPTIONS_INVALID_INFLATION": int32(SET_OPTIONS_INVALID_INFLATION),
	"SET_OPTIONS_CANT_CHANGE": int32(SET_OPTIONS_CANT_CHANGE),
	"SET_OPTIONS_UNKNOWN_FLAG": int32(SET_OPTIONS_UNKNOWN_FLAG),
	"SET_OPTIONS_THRESHOLD_OUT_OF_RANGE": int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE),
	"SET_OPTIONS_BAD_SIGNER": int32(SET_OPTIONS_BAD_SIGNER),
	"SET_OPTIONS_INVALID_HOME_DOMAIN": int32(SET_OPTIONS_INVALID_HOME_DOMAIN),
}
func (SetOptionsResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SetOptionsResultCode
}
func (v SetOptionsResultCode) String() string {
	if s, ok := _XdrNames_SetOptionsResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SetOptionsResultCode#%d", v)
}
func (v *SetOptionsResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SetOptionsResultCode[stok]; ok {
			*v = SetOptionsResultCode(val)
			return nil
		} else if stok == "SetOptionsResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SetOptionsResultCode.", stok))
	}
}
func (v SetOptionsResultCode) GetU32() uint32 { return uint32(v) }
func (v *SetOptionsResultCode) SetU32(n uint32) { *v = SetOptionsResultCode(n) }
func (v *SetOptionsResultCode) XdrPointer() interface{} { return v }
func (v SetOptionsResultCode) XdrValue() interface{} { return v }
func (v *SetOptionsResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_SetOptionsResultCode(v *SetOptionsResultCode) *SetOptionsResultCode { return v }
var _XdrComments_SetOptionsResultCode = map[int32]string {
	int32(SET_OPTIONS_SUCCESS): "codes considered as \"success\" for the operation",
	int32(SET_OPTIONS_LOW_RESERVE): "not enough funds to add a signer",
	int32(SET_OPTIONS_TOO_MANY_SIGNERS): "max number of signers already reached",
	int32(SET_OPTIONS_BAD_FLAGS): "invalid combination of clear/set flags",
	int32(SET_OPTIONS_INVALID_INFLATION): "inflation account does not exist",
	int32(SET_OPTIONS_CANT_CHANGE): "can no longer change this option",
	int32(SET_OPTIONS_UNKNOWN_FLAG): "can't set an unknown flag",
	int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE): "bad value for weight/threshold",
	int32(SET_OPTIONS_BAD_SIGNER): "signer cannot be masterkey",
	int32(SET_OPTIONS_INVALID_HOME_DOMAIN): "malformed home domain",
}
func (e SetOptionsResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_SetOptionsResultCode
}
func (u SetOptionsResult) XdrValid() bool {
	return true
}
func (u *SetOptionsResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *SetOptionsResult) XdrUnionTagName() string {
	return "Code"
}
func (u *SetOptionsResult) XdrUnionBody() interface{} {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *SetOptionsResult) XdrUnionBodyName() string {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *SetOptionsResult) XdrPointer() interface{} { return v }
func (v SetOptionsResult) XdrValue() interface{} { return v }
func (v *SetOptionsResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SetOptionsResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SetOptionsResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return
	default:
		return
	}
}
func XDR_SetOptionsResult(v *SetOptionsResult) *SetOptionsResult { return v}
var _XdrNames_ChangeTrustResultCode = map[int32]string{
	int32(CHANGE_TRUST_SUCCESS): "CHANGE_TRUST_SUCCESS",
	int32(CHANGE_TRUST_MALFORMED): "CHANGE_TRUST_MALFORMED",
	int32(CHANGE_TRUST_NO_ISSUER): "CHANGE_TRUST_NO_ISSUER",
	int32(CHANGE_TRUST_INVALID_LIMIT): "CHANGE_TRUST_INVALID_LIMIT",
	int32(CHANGE_TRUST_LOW_RESERVE): "CHANGE_TRUST_LOW_RESERVE",
	int32(CHANGE_TRUST_SELF_NOT_ALLOWED): "CHANGE_TRUST_SELF_NOT_ALLOWED",
}
var _XdrValues_ChangeTrustResultCode = map[string]int32{
	"CHANGE_TRUST_SUCCESS": int32(CHANGE_TRUST_SUCCESS),
	"CHANGE_TRUST_MALFORMED": int32(CHANGE_TRUST_MALFORMED),
	"CHANGE_TRUST_NO_ISSUER": int32(CHANGE_TRUST_NO_ISSUER),
	"CHANGE_TRUST_INVALID_LIMIT": int32(CHANGE_TRUST_INVALID_LIMIT),
	"CHANGE_TRUST_LOW_RESERVE": int32(CHANGE_TRUST_LOW_RESERVE),
	"CHANGE_TRUST_SELF_NOT_ALLOWED": int32(CHANGE_TRUST_SELF_NOT_ALLOWED),
}
func (ChangeTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ChangeTrustResultCode
}
func (v ChangeTrustResultCode) String() string {
	if s, ok := _XdrNames_ChangeTrustResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ChangeTrustResultCode#%d", v)
}
func (v *ChangeTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ChangeTrustResultCode[stok]; ok {
			*v = ChangeTrustResultCode(val)
			return nil
		} else if stok == "ChangeTrustResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ChangeTrustResultCode.", stok))
	}
}
func (v ChangeTrustResultCode) GetU32() uint32 { return uint32(v) }
func (v *ChangeTrustResultCode) SetU32(n uint32) { *v = ChangeTrustResultCode(n) }
func (v *ChangeTrustResultCode) XdrPointer() interface{} { return v }
func (v ChangeTrustResultCode) XdrValue() interface{} { return v }
func (v *ChangeTrustResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_ChangeTrustResultCode(v *ChangeTrustResultCode) *ChangeTrustResultCode { return v }
var _XdrComments_ChangeTrustResultCode = map[int32]string {
	int32(CHANGE_TRUST_SUCCESS): "codes considered as \"success\" for the operation",
	int32(CHANGE_TRUST_MALFORMED): "bad input",
	int32(CHANGE_TRUST_NO_ISSUER): "could not find issuer",
	int32(CHANGE_TRUST_INVALID_LIMIT): "cannot drop limit below balance",
	int32(CHANGE_TRUST_LOW_RESERVE): "not enough funds to create a new trust line,",
	int32(CHANGE_TRUST_SELF_NOT_ALLOWED): "trusting self is not allowed",
}
func (e ChangeTrustResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ChangeTrustResultCode
}
func (u ChangeTrustResult) XdrValid() bool {
	return true
}
func (u *ChangeTrustResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *ChangeTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ChangeTrustResult) XdrUnionBody() interface{} {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *ChangeTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *ChangeTrustResult) XdrPointer() interface{} { return v }
func (v ChangeTrustResult) XdrValue() interface{} { return v }
func (v *ChangeTrustResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ChangeTrustResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ChangeTrustResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return
	default:
		return
	}
}
func XDR_ChangeTrustResult(v *ChangeTrustResult) *ChangeTrustResult { return v}
var _XdrNames_AllowTrustResultCode = map[int32]string{
	int32(ALLOW_TRUST_SUCCESS): "ALLOW_TRUST_SUCCESS",
	int32(ALLOW_TRUST_MALFORMED): "ALLOW_TRUST_MALFORMED",
	int32(ALLOW_TRUST_NO_TRUST_LINE): "ALLOW_TRUST_NO_TRUST_LINE",
	int32(ALLOW_TRUST_TRUST_NOT_REQUIRED): "ALLOW_TRUST_TRUST_NOT_REQUIRED",
	int32(ALLOW_TRUST_CANT_REVOKE): "ALLOW_TRUST_CANT_REVOKE",
	int32(ALLOW_TRUST_SELF_NOT_ALLOWED): "ALLOW_TRUST_SELF_NOT_ALLOWED",
}
var _XdrValues_AllowTrustResultCode = map[string]int32{
	"ALLOW_TRUST_SUCCESS": int32(ALLOW_TRUST_SUCCESS),
	"ALLOW_TRUST_MALFORMED": int32(ALLOW_TRUST_MALFORMED),
	"ALLOW_TRUST_NO_TRUST_LINE": int32(ALLOW_TRUST_NO_TRUST_LINE),
	"ALLOW_TRUST_TRUST_NOT_REQUIRED": int32(ALLOW_TRUST_TRUST_NOT_REQUIRED),
	"ALLOW_TRUST_CANT_REVOKE": int32(ALLOW_TRUST_CANT_REVOKE),
	"ALLOW_TRUST_SELF_NOT_ALLOWED": int32(ALLOW_TRUST_SELF_NOT_ALLOWED),
}
func (AllowTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AllowTrustResultCode
}
func (v AllowTrustResultCode) String() string {
	if s, ok := _XdrNames_AllowTrustResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AllowTrustResultCode#%d", v)
}
func (v *AllowTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AllowTrustResultCode[stok]; ok {
			*v = AllowTrustResultCode(val)
			return nil
		} else if stok == "AllowTrustResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AllowTrustResultCode.", stok))
	}
}
func (v AllowTrustResultCode) GetU32() uint32 { return uint32(v) }
func (v *AllowTrustResultCode) SetU32(n uint32) { *v = AllowTrustResultCode(n) }
func (v *AllowTrustResultCode) XdrPointer() interface{} { return v }
func (v AllowTrustResultCode) XdrValue() interface{} { return v }
func (v *AllowTrustResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_AllowTrustResultCode(v *AllowTrustResultCode) *AllowTrustResultCode { return v }
var _XdrComments_AllowTrustResultCode = map[int32]string {
	int32(ALLOW_TRUST_SUCCESS): "codes considered as \"success\" for the operation",
	int32(ALLOW_TRUST_MALFORMED): "asset is not ASSET_TYPE_ALPHANUM",
	int32(ALLOW_TRUST_NO_TRUST_LINE): "trustor does not have a trustline",
	int32(ALLOW_TRUST_TRUST_NOT_REQUIRED): "source account does not require trust",
	int32(ALLOW_TRUST_CANT_REVOKE): "source account can't revoke trust,",
	int32(ALLOW_TRUST_SELF_NOT_ALLOWED): "trusting self is not allowed",
}
func (e AllowTrustResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_AllowTrustResultCode
}
func (u AllowTrustResult) XdrValid() bool {
	return true
}
func (u *AllowTrustResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *AllowTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AllowTrustResult) XdrUnionBody() interface{} {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *AllowTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *AllowTrustResult) XdrPointer() interface{} { return v }
func (v AllowTrustResult) XdrValue() interface{} { return v }
func (v *AllowTrustResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AllowTrustResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AllowTrustResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return
	default:
		return
	}
}
func XDR_AllowTrustResult(v *AllowTrustResult) *AllowTrustResult { return v}
var _XdrNames_AccountMergeResultCode = map[int32]string{
	int32(ACCOUNT_MERGE_SUCCESS): "ACCOUNT_MERGE_SUCCESS",
	int32(ACCOUNT_MERGE_MALFORMED): "ACCOUNT_MERGE_MALFORMED",
	int32(ACCOUNT_MERGE_NO_ACCOUNT): "ACCOUNT_MERGE_NO_ACCOUNT",
	int32(ACCOUNT_MERGE_IMMUTABLE_SET): "ACCOUNT_MERGE_IMMUTABLE_SET",
	int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): "ACCOUNT_MERGE_HAS_SUB_ENTRIES",
	int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR): "ACCOUNT_MERGE_SEQNUM_TOO_FAR",
	int32(ACCOUNT_MERGE_DEST_FULL): "ACCOUNT_MERGE_DEST_FULL",
}
var _XdrValues_AccountMergeResultCode = map[string]int32{
	"ACCOUNT_MERGE_SUCCESS": int32(ACCOUNT_MERGE_SUCCESS),
	"ACCOUNT_MERGE_MALFORMED": int32(ACCOUNT_MERGE_MALFORMED),
	"ACCOUNT_MERGE_NO_ACCOUNT": int32(ACCOUNT_MERGE_NO_ACCOUNT),
	"ACCOUNT_MERGE_IMMUTABLE_SET": int32(ACCOUNT_MERGE_IMMUTABLE_SET),
	"ACCOUNT_MERGE_HAS_SUB_ENTRIES": int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES),
	"ACCOUNT_MERGE_SEQNUM_TOO_FAR": int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR),
	"ACCOUNT_MERGE_DEST_FULL": int32(ACCOUNT_MERGE_DEST_FULL),
}
func (AccountMergeResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountMergeResultCode
}
func (v AccountMergeResultCode) String() string {
	if s, ok := _XdrNames_AccountMergeResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountMergeResultCode#%d", v)
}
func (v *AccountMergeResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountMergeResultCode[stok]; ok {
			*v = AccountMergeResultCode(val)
			return nil
		} else if stok == "AccountMergeResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountMergeResultCode.", stok))
	}
}
func (v AccountMergeResultCode) GetU32() uint32 { return uint32(v) }
func (v *AccountMergeResultCode) SetU32(n uint32) { *v = AccountMergeResultCode(n) }
func (v *AccountMergeResultCode) XdrPointer() interface{} { return v }
func (v AccountMergeResultCode) XdrValue() interface{} { return v }
func (v *AccountMergeResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_AccountMergeResultCode(v *AccountMergeResultCode) *AccountMergeResultCode { return v }
var _XdrComments_AccountMergeResultCode = map[int32]string {
	int32(ACCOUNT_MERGE_SUCCESS): "codes considered as \"success\" for the operation",
	int32(ACCOUNT_MERGE_MALFORMED): "can't merge onto itself",
	int32(ACCOUNT_MERGE_NO_ACCOUNT): "destination does not exist",
	int32(ACCOUNT_MERGE_IMMUTABLE_SET): "source account has AUTH_IMMUTABLE set",
	int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): "account has trust lines/offers",
	int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR): "sequence number is over max allowed",
	int32(ACCOUNT_MERGE_DEST_FULL): "can't add source balance to",
}
func (e AccountMergeResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_AccountMergeResultCode
}
// how much got transfered from source account
func (u *AccountMergeResult) SourceAccountBalance() *Int64 {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AccountMergeResult.SourceAccountBalance accessed when Code == %v", u.Code)
		return nil
	}
}
func (u AccountMergeResult) XdrValid() bool {
	return true
}
func (u *AccountMergeResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *AccountMergeResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AccountMergeResult) XdrUnionBody() interface{} {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return u.SourceAccountBalance()
	default:
		return nil
	}
}
func (u *AccountMergeResult) XdrUnionBodyName() string {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return "SourceAccountBalance"
	default:
		return ""
	}
}
func (v *AccountMergeResult) XdrPointer() interface{} { return v }
func (v AccountMergeResult) XdrValue() interface{} { return v }
func (v *AccountMergeResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AccountMergeResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountMergeResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		XDR_Int64(u.SourceAccountBalance()).XdrMarshal(x, x.Sprintf("%ssourceAccountBalance", name))
		return
	default:
		return
	}
}
func XDR_AccountMergeResult(v *AccountMergeResult) *AccountMergeResult { return v}
var _XdrNames_InflationResultCode = map[int32]string{
	int32(INFLATION_SUCCESS): "INFLATION_SUCCESS",
	int32(INFLATION_NOT_TIME): "INFLATION_NOT_TIME",
}
var _XdrValues_InflationResultCode = map[string]int32{
	"INFLATION_SUCCESS": int32(INFLATION_SUCCESS),
	"INFLATION_NOT_TIME": int32(INFLATION_NOT_TIME),
}
func (InflationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_InflationResultCode
}
func (v InflationResultCode) String() string {
	if s, ok := _XdrNames_InflationResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("InflationResultCode#%d", v)
}
func (v *InflationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_InflationResultCode[stok]; ok {
			*v = InflationResultCode(val)
			return nil
		} else if stok == "InflationResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid InflationResultCode.", stok))
	}
}
func (v InflationResultCode) GetU32() uint32 { return uint32(v) }
func (v *InflationResultCode) SetU32(n uint32) { *v = InflationResultCode(n) }
func (v *InflationResultCode) XdrPointer() interface{} { return v }
func (v InflationResultCode) XdrValue() interface{} { return v }
func (v *InflationResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_InflationResultCode(v *InflationResultCode) *InflationResultCode { return v }
var _XdrComments_InflationResultCode = map[int32]string {
	int32(INFLATION_SUCCESS): "codes considered as \"success\" for the operation",
	int32(INFLATION_NOT_TIME): "codes considered as \"failure\" for the operation",
}
func (e InflationResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_InflationResultCode
}
func (v *InflationPayout) XdrPointer() interface{} { return v }
func (v InflationPayout) XdrValue() interface{} { return v }
func (v *InflationPayout) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InflationPayout) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(&v.Destination).XdrMarshal(x, x.Sprintf("%sdestination", name))
	XDR_Int64(&v.Amount).XdrMarshal(x, x.Sprintf("%samount", name))
}
func XDR_InflationPayout(v *InflationPayout) *InflationPayout { return v }
type _XdrVec_unbounded_InflationPayout []InflationPayout
func (_XdrVec_unbounded_InflationPayout) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_InflationPayout) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_InflationPayout length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_InflationPayout length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_InflationPayout) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_InflationPayout) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]InflationPayout, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_InflationPayout) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_InflationPayout(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_InflationPayout) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_InflationPayout) XdrPointer() interface{} { return (*[]InflationPayout)(v) }
func (v _XdrVec_unbounded_InflationPayout) XdrValue() interface{} { return ([]InflationPayout)(v) }
func (v *_XdrVec_unbounded_InflationPayout) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *InflationResult) Payouts() *[]InflationPayout {
	switch u.Code {
	case INFLATION_SUCCESS:
		if v, ok := u._u.(*[]InflationPayout); ok {
			return v
		} else {
			var zero []InflationPayout
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("InflationResult.Payouts accessed when Code == %v", u.Code)
		return nil
	}
}
func (u InflationResult) XdrValid() bool {
	return true
}
func (u *InflationResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *InflationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *InflationResult) XdrUnionBody() interface{} {
	switch u.Code {
	case INFLATION_SUCCESS:
		return u.Payouts()
	default:
		return nil
	}
}
func (u *InflationResult) XdrUnionBodyName() string {
	switch u.Code {
	case INFLATION_SUCCESS:
		return "Payouts"
	default:
		return ""
	}
}
func (v *InflationResult) XdrPointer() interface{} { return v }
func (v InflationResult) XdrValue() interface{} { return v }
func (v *InflationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *InflationResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_InflationResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case INFLATION_SUCCESS:
		x.Marshal(x.Sprintf("%spayouts", name), (*_XdrVec_unbounded_InflationPayout)(u.Payouts()))
		return
	default:
		return
	}
}
func XDR_InflationResult(v *InflationResult) *InflationResult { return v}
var _XdrNames_ManageDataResultCode = map[int32]string{
	int32(MANAGE_DATA_SUCCESS): "MANAGE_DATA_SUCCESS",
	int32(MANAGE_DATA_NOT_SUPPORTED_YET): "MANAGE_DATA_NOT_SUPPORTED_YET",
	int32(MANAGE_DATA_NAME_NOT_FOUND): "MANAGE_DATA_NAME_NOT_FOUND",
	int32(MANAGE_DATA_LOW_RESERVE): "MANAGE_DATA_LOW_RESERVE",
	int32(MANAGE_DATA_INVALID_NAME): "MANAGE_DATA_INVALID_NAME",
}
var _XdrValues_ManageDataResultCode = map[string]int32{
	"MANAGE_DATA_SUCCESS": int32(MANAGE_DATA_SUCCESS),
	"MANAGE_DATA_NOT_SUPPORTED_YET": int32(MANAGE_DATA_NOT_SUPPORTED_YET),
	"MANAGE_DATA_NAME_NOT_FOUND": int32(MANAGE_DATA_NAME_NOT_FOUND),
	"MANAGE_DATA_LOW_RESERVE": int32(MANAGE_DATA_LOW_RESERVE),
	"MANAGE_DATA_INVALID_NAME": int32(MANAGE_DATA_INVALID_NAME),
}
func (ManageDataResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageDataResultCode
}
func (v ManageDataResultCode) String() string {
	if s, ok := _XdrNames_ManageDataResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageDataResultCode#%d", v)
}
func (v *ManageDataResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageDataResultCode[stok]; ok {
			*v = ManageDataResultCode(val)
			return nil
		} else if stok == "ManageDataResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageDataResultCode.", stok))
	}
}
func (v ManageDataResultCode) GetU32() uint32 { return uint32(v) }
func (v *ManageDataResultCode) SetU32(n uint32) { *v = ManageDataResultCode(n) }
func (v *ManageDataResultCode) XdrPointer() interface{} { return v }
func (v ManageDataResultCode) XdrValue() interface{} { return v }
func (v *ManageDataResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_ManageDataResultCode(v *ManageDataResultCode) *ManageDataResultCode { return v }
var _XdrComments_ManageDataResultCode = map[int32]string {
	int32(MANAGE_DATA_SUCCESS): "codes considered as \"success\" for the operation",
	int32(MANAGE_DATA_NOT_SUPPORTED_YET): "The network hasn't moved to this protocol change yet",
	int32(MANAGE_DATA_NAME_NOT_FOUND): "Trying to remove a Data Entry that isn't there",
	int32(MANAGE_DATA_LOW_RESERVE): "not enough funds to create a new Data Entry",
	int32(MANAGE_DATA_INVALID_NAME): "Name not a valid string",
}
func (e ManageDataResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageDataResultCode
}
func (u ManageDataResult) XdrValid() bool {
	return true
}
func (u *ManageDataResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *ManageDataResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageDataResult) XdrUnionBody() interface{} {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *ManageDataResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *ManageDataResult) XdrPointer() interface{} { return v }
func (v ManageDataResult) XdrValue() interface{} { return v }
func (v *ManageDataResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageDataResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageDataResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return
	default:
		return
	}
}
func XDR_ManageDataResult(v *ManageDataResult) *ManageDataResult { return v}
var _XdrNames_BumpSequenceResultCode = map[int32]string{
	int32(BUMP_SEQUENCE_SUCCESS): "BUMP_SEQUENCE_SUCCESS",
	int32(BUMP_SEQUENCE_BAD_SEQ): "BUMP_SEQUENCE_BAD_SEQ",
}
var _XdrValues_BumpSequenceResultCode = map[string]int32{
	"BUMP_SEQUENCE_SUCCESS": int32(BUMP_SEQUENCE_SUCCESS),
	"BUMP_SEQUENCE_BAD_SEQ": int32(BUMP_SEQUENCE_BAD_SEQ),
}
func (BumpSequenceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_BumpSequenceResultCode
}
func (v BumpSequenceResultCode) String() string {
	if s, ok := _XdrNames_BumpSequenceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BumpSequenceResultCode#%d", v)
}
func (v *BumpSequenceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BumpSequenceResultCode[stok]; ok {
			*v = BumpSequenceResultCode(val)
			return nil
		} else if stok == "BumpSequenceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BumpSequenceResultCode.", stok))
	}
}
func (v BumpSequenceResultCode) GetU32() uint32 { return uint32(v) }
func (v *BumpSequenceResultCode) SetU32(n uint32) { *v = BumpSequenceResultCode(n) }
func (v *BumpSequenceResultCode) XdrPointer() interface{} { return v }
func (v BumpSequenceResultCode) XdrValue() interface{} { return v }
func (v *BumpSequenceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_BumpSequenceResultCode(v *BumpSequenceResultCode) *BumpSequenceResultCode { return v }
var _XdrComments_BumpSequenceResultCode = map[int32]string {
	int32(BUMP_SEQUENCE_SUCCESS): "codes considered as \"success\" for the operation",
	int32(BUMP_SEQUENCE_BAD_SEQ): "codes considered as \"failure\" for the operation",
}
func (e BumpSequenceResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_BumpSequenceResultCode
}
func (u BumpSequenceResult) XdrValid() bool {
	return true
}
func (u *BumpSequenceResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *BumpSequenceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *BumpSequenceResult) XdrUnionBody() interface{} {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *BumpSequenceResult) XdrUnionBodyName() string {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *BumpSequenceResult) XdrPointer() interface{} { return v }
func (v BumpSequenceResult) XdrValue() interface{} { return v }
func (v *BumpSequenceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BumpSequenceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BumpSequenceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return
	default:
		return
	}
}
func XDR_BumpSequenceResult(v *BumpSequenceResult) *BumpSequenceResult { return v}
var _XdrNames_OperationResultCode = map[int32]string{
	int32(OpINNER): "opINNER",
	int32(OpBAD_AUTH): "opBAD_AUTH",
	int32(OpNO_ACCOUNT): "opNO_ACCOUNT",
	int32(OpNOT_SUPPORTED): "opNOT_SUPPORTED",
	int32(OpTOO_MANY_SUBENTRIES): "opTOO_MANY_SUBENTRIES",
	int32(OpEXCEEDED_WORK_LIMIT): "opEXCEEDED_WORK_LIMIT",
}
var _XdrValues_OperationResultCode = map[string]int32{
	"opINNER": int32(OpINNER),
	"opBAD_AUTH": int32(OpBAD_AUTH),
	"opNO_ACCOUNT": int32(OpNO_ACCOUNT),
	"opNOT_SUPPORTED": int32(OpNOT_SUPPORTED),
	"opTOO_MANY_SUBENTRIES": int32(OpTOO_MANY_SUBENTRIES),
	"opEXCEEDED_WORK_LIMIT": int32(OpEXCEEDED_WORK_LIMIT),
}
func (OperationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationResultCode
}
func (v OperationResultCode) String() string {
	if s, ok := _XdrNames_OperationResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationResultCode#%d", v)
}
func (v *OperationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationResultCode[stok]; ok {
			*v = OperationResultCode(val)
			return nil
		} else if stok == "OperationResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationResultCode.", stok))
	}
}
func (v OperationResultCode) GetU32() uint32 { return uint32(v) }
func (v *OperationResultCode) SetU32(n uint32) { *v = OperationResultCode(n) }
func (v *OperationResultCode) XdrPointer() interface{} { return v }
func (v OperationResultCode) XdrValue() interface{} { return v }
func (v *OperationResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_OperationResultCode(v *OperationResultCode) *OperationResultCode { return v }
var _XdrComments_OperationResultCode = map[int32]string {
	int32(OpINNER): "inner object result is valid",
	int32(OpBAD_AUTH): "too few valid signatures / wrong network",
	int32(OpNO_ACCOUNT): "source account was not found",
	int32(OpNOT_SUPPORTED): "operation not supported at this time",
	int32(OpTOO_MANY_SUBENTRIES): "max number of subentries already reached",
	int32(OpEXCEEDED_WORK_LIMIT): "operation did too much work",
}
func (e OperationResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_OperationResultCode
}
func (u *XdrAnon_OperationResult_Tr) CreateAccountResult() *CreateAccountResult {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountResult); ok {
			return v
		} else {
			var zero CreateAccountResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreateAccountResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PaymentResult() *PaymentResult {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentResult); ok {
			return v
		} else {
			var zero PaymentResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PaymentResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PathPaymentStrictReceiveResult() *PathPaymentStrictReceiveResult {
	switch u.Type {
	case PATH_PAYMENT_STRICT_RECEIVE:
		if v, ok := u._u.(*PathPaymentStrictReceiveResult); ok {
			return v
		} else {
			var zero PathPaymentStrictReceiveResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PathPaymentStrictReceiveResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageSellOfferResult() *ManageSellOfferResult {
	switch u.Type {
	case MANAGE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferResult); ok {
			return v
		} else {
			var zero ManageSellOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageSellOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) CreatePassiveSellOfferResult() *ManageSellOfferResult {
	switch u.Type {
	case CREATE_PASSIVE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferResult); ok {
			return v
		} else {
			var zero ManageSellOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreatePassiveSellOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) SetOptionsResult() *SetOptionsResult {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsResult); ok {
			return v
		} else {
			var zero SetOptionsResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.SetOptionsResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ChangeTrustResult() *ChangeTrustResult {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustResult); ok {
			return v
		} else {
			var zero ChangeTrustResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ChangeTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) AllowTrustResult() *AllowTrustResult {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustResult); ok {
			return v
		} else {
			var zero AllowTrustResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.AllowTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) AccountMergeResult() *AccountMergeResult {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*AccountMergeResult); ok {
			return v
		} else {
			var zero AccountMergeResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.AccountMergeResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) InflationResult() *InflationResult {
	switch u.Type {
	case INFLATION:
		if v, ok := u._u.(*InflationResult); ok {
			return v
		} else {
			var zero InflationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.InflationResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageDataResult() *ManageDataResult {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataResult); ok {
			return v
		} else {
			var zero ManageDataResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageDataResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) BumpSeqResult() *BumpSequenceResult {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceResult); ok {
			return v
		} else {
			var zero BumpSequenceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.BumpSeqResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageBuyOfferResult() *ManageBuyOfferResult {
	switch u.Type {
	case MANAGE_BUY_OFFER:
		if v, ok := u._u.(*ManageBuyOfferResult); ok {
			return v
		} else {
			var zero ManageBuyOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageBuyOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PathPaymentStrictSendResult() *PathPaymentStrictSendResult {
	switch u.Type {
	case PATH_PAYMENT_STRICT_SEND:
		if v, ok := u._u.(*PathPaymentStrictSendResult); ok {
			return v
		} else {
			var zero PathPaymentStrictSendResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PathPaymentStrictSendResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_OperationResult_Tr) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT,PAYMENT,PATH_PAYMENT_STRICT_RECEIVE,MANAGE_SELL_OFFER,CREATE_PASSIVE_SELL_OFFER,SET_OPTIONS,CHANGE_TRUST,ALLOW_TRUST,ACCOUNT_MERGE,INFLATION,MANAGE_DATA,BUMP_SEQUENCE,MANAGE_BUY_OFFER,PATH_PAYMENT_STRICT_SEND:
		return true
	}
	return false
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionBody() interface{} {
	switch u.Type {
	case CREATE_ACCOUNT:
		return u.CreateAccountResult()
	case PAYMENT:
		return u.PaymentResult()
	case PATH_PAYMENT_STRICT_RECEIVE:
		return u.PathPaymentStrictReceiveResult()
	case MANAGE_SELL_OFFER:
		return u.ManageSellOfferResult()
	case CREATE_PASSIVE_SELL_OFFER:
		return u.CreatePassiveSellOfferResult()
	case SET_OPTIONS:
		return u.SetOptionsResult()
	case CHANGE_TRUST:
		return u.ChangeTrustResult()
	case ALLOW_TRUST:
		return u.AllowTrustResult()
	case ACCOUNT_MERGE:
		return u.AccountMergeResult()
	case INFLATION:
		return u.InflationResult()
	case MANAGE_DATA:
		return u.ManageDataResult()
	case BUMP_SEQUENCE:
		return u.BumpSeqResult()
	case MANAGE_BUY_OFFER:
		return u.ManageBuyOfferResult()
	case PATH_PAYMENT_STRICT_SEND:
		return u.PathPaymentStrictSendResult()
	}
	return nil
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountResult"
	case PAYMENT:
		return "PaymentResult"
	case PATH_PAYMENT_STRICT_RECEIVE:
		return "PathPaymentStrictReceiveResult"
	case MANAGE_SELL_OFFER:
		return "ManageSellOfferResult"
	case CREATE_PASSIVE_SELL_OFFER:
		return "CreatePassiveSellOfferResult"
	case SET_OPTIONS:
		return "SetOptionsResult"
	case CHANGE_TRUST:
		return "ChangeTrustResult"
	case ALLOW_TRUST:
		return "AllowTrustResult"
	case ACCOUNT_MERGE:
		return "AccountMergeResult"
	case INFLATION:
		return "InflationResult"
	case MANAGE_DATA:
		return "ManageDataResult"
	case BUMP_SEQUENCE:
		return "BumpSeqResult"
	case MANAGE_BUY_OFFER:
		return "ManageBuyOfferResult"
	case PATH_PAYMENT_STRICT_SEND:
		return "PathPaymentStrictSendResult"
	}
	return ""
}
func (v *XdrAnon_OperationResult_Tr) XdrPointer() interface{} { return v }
func (v XdrAnon_OperationResult_Tr) XdrValue() interface{} { return v }
func (v *XdrAnon_OperationResult_Tr) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_OperationResult_Tr) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CREATE_ACCOUNT:
		XDR_CreateAccountResult(u.CreateAccountResult()).XdrMarshal(x, x.Sprintf("%screateAccountResult", name))
		return
	case PAYMENT:
		XDR_PaymentResult(u.PaymentResult()).XdrMarshal(x, x.Sprintf("%spaymentResult", name))
		return
	case PATH_PAYMENT_STRICT_RECEIVE:
		XDR_PathPaymentStrictReceiveResult(u.PathPaymentStrictReceiveResult()).XdrMarshal(x, x.Sprintf("%spathPaymentStrictReceiveResult", name))
		return
	case MANAGE_SELL_OFFER:
		XDR_ManageSellOfferResult(u.ManageSellOfferResult()).XdrMarshal(x, x.Sprintf("%smanageSellOfferResult", name))
		return
	case CREATE_PASSIVE_SELL_OFFER:
		XDR_ManageSellOfferResult(u.CreatePassiveSellOfferResult()).XdrMarshal(x, x.Sprintf("%screatePassiveSellOfferResult", name))
		return
	case SET_OPTIONS:
		XDR_SetOptionsResult(u.SetOptionsResult()).XdrMarshal(x, x.Sprintf("%ssetOptionsResult", name))
		return
	case CHANGE_TRUST:
		XDR_ChangeTrustResult(u.ChangeTrustResult()).XdrMarshal(x, x.Sprintf("%schangeTrustResult", name))
		return
	case ALLOW_TRUST:
		XDR_AllowTrustResult(u.AllowTrustResult()).XdrMarshal(x, x.Sprintf("%sallowTrustResult", name))
		return
	case ACCOUNT_MERGE:
		XDR_AccountMergeResult(u.AccountMergeResult()).XdrMarshal(x, x.Sprintf("%saccountMergeResult", name))
		return
	case INFLATION:
		XDR_InflationResult(u.InflationResult()).XdrMarshal(x, x.Sprintf("%sinflationResult", name))
		return
	case MANAGE_DATA:
		XDR_ManageDataResult(u.ManageDataResult()).XdrMarshal(x, x.Sprintf("%smanageDataResult", name))
		return
	case BUMP_SEQUENCE:
		XDR_BumpSequenceResult(u.BumpSeqResult()).XdrMarshal(x, x.Sprintf("%sbumpSeqResult", name))
		return
	case MANAGE_BUY_OFFER:
		XDR_ManageBuyOfferResult(u.ManageBuyOfferResult()).XdrMarshal(x, x.Sprintf("%smanageBuyOfferResult", name))
		return
	case PATH_PAYMENT_STRICT_SEND:
		XDR_PathPaymentStrictSendResult(u.PathPaymentStrictSendResult()).XdrMarshal(x, x.Sprintf("%spathPaymentStrictSendResult", name))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_OperationResult_Tr", u.Type)
}
func XDR_XdrAnon_OperationResult_Tr(v *XdrAnon_OperationResult_Tr) *XdrAnon_OperationResult_Tr { return v}
func (u *OperationResult) Tr() *XdrAnon_OperationResult_Tr {
	switch u.Code {
	case OpINNER:
		if v, ok := u._u.(*XdrAnon_OperationResult_Tr); ok {
			return v
		} else {
			var zero XdrAnon_OperationResult_Tr
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("OperationResult.Tr accessed when Code == %v", u.Code)
		return nil
	}
}
func (u OperationResult) XdrValid() bool {
	return true
}
func (u *OperationResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *OperationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *OperationResult) XdrUnionBody() interface{} {
	switch u.Code {
	case OpINNER:
		return u.Tr()
	default:
		return nil
	}
}
func (u *OperationResult) XdrUnionBodyName() string {
	switch u.Code {
	case OpINNER:
		return "Tr"
	default:
		return ""
	}
}
func (v *OperationResult) XdrPointer() interface{} { return v }
func (v OperationResult) XdrValue() interface{} { return v }
func (v *OperationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *OperationResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case OpINNER:
		XDR_XdrAnon_OperationResult_Tr(u.Tr()).XdrMarshal(x, x.Sprintf("%str", name))
		return
	default:
		return
	}
}
func XDR_OperationResult(v *OperationResult) *OperationResult { return v}
var _XdrNames_TransactionResultCode = map[int32]string{
	int32(TxSUCCESS): "txSUCCESS",
	int32(TxFAILED): "txFAILED",
	int32(TxTOO_EARLY): "txTOO_EARLY",
	int32(TxTOO_LATE): "txTOO_LATE",
	int32(TxMISSING_OPERATION): "txMISSING_OPERATION",
	int32(TxBAD_SEQ): "txBAD_SEQ",
	int32(TxBAD_AUTH): "txBAD_AUTH",
	int32(TxINSUFFICIENT_BALANCE): "txINSUFFICIENT_BALANCE",
	int32(TxNO_ACCOUNT): "txNO_ACCOUNT",
	int32(TxINSUFFICIENT_FEE): "txINSUFFICIENT_FEE",
	int32(TxBAD_AUTH_EXTRA): "txBAD_AUTH_EXTRA",
	int32(TxINTERNAL_ERROR): "txINTERNAL_ERROR",
}
var _XdrValues_TransactionResultCode = map[string]int32{
	"txSUCCESS": int32(TxSUCCESS),
	"txFAILED": int32(TxFAILED),
	"txTOO_EARLY": int32(TxTOO_EARLY),
	"txTOO_LATE": int32(TxTOO_LATE),
	"txMISSING_OPERATION": int32(TxMISSING_OPERATION),
	"txBAD_SEQ": int32(TxBAD_SEQ),
	"txBAD_AUTH": int32(TxBAD_AUTH),
	"txINSUFFICIENT_BALANCE": int32(TxINSUFFICIENT_BALANCE),
	"txNO_ACCOUNT": int32(TxNO_ACCOUNT),
	"txINSUFFICIENT_FEE": int32(TxINSUFFICIENT_FEE),
	"txBAD_AUTH_EXTRA": int32(TxBAD_AUTH_EXTRA),
	"txINTERNAL_ERROR": int32(TxINTERNAL_ERROR),
}
func (TransactionResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_TransactionResultCode
}
func (v TransactionResultCode) String() string {
	if s, ok := _XdrNames_TransactionResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TransactionResultCode#%d", v)
}
func (v *TransactionResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TransactionResultCode[stok]; ok {
			*v = TransactionResultCode(val)
			return nil
		} else if stok == "TransactionResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TransactionResultCode.", stok))
	}
}
func (v TransactionResultCode) GetU32() uint32 { return uint32(v) }
func (v *TransactionResultCode) SetU32(n uint32) { *v = TransactionResultCode(n) }
func (v *TransactionResultCode) XdrPointer() interface{} { return v }
func (v TransactionResultCode) XdrValue() interface{} { return v }
func (v *TransactionResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_TransactionResultCode(v *TransactionResultCode) *TransactionResultCode { return v }
var _XdrComments_TransactionResultCode = map[int32]string {
	int32(TxSUCCESS): "all operations succeeded",
	int32(TxFAILED): "one of the operations failed (none were applied)",
	int32(TxTOO_EARLY): "ledger closeTime before minTime",
	int32(TxTOO_LATE): "ledger closeTime after maxTime",
	int32(TxMISSING_OPERATION): "no operation was specified",
	int32(TxBAD_SEQ): "sequence number does not match source account",
	int32(TxBAD_AUTH): "too few valid signatures / wrong network",
	int32(TxINSUFFICIENT_BALANCE): "fee would bring account below reserve",
	int32(TxNO_ACCOUNT): "source account not found",
	int32(TxINSUFFICIENT_FEE): "fee is too small",
	int32(TxBAD_AUTH_EXTRA): "unused signatures attached to transaction",
	int32(TxINTERNAL_ERROR): "an unknown error occured",
}
func (e TransactionResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_TransactionResultCode
}
type _XdrVec_unbounded_OperationResult []OperationResult
func (_XdrVec_unbounded_OperationResult) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_OperationResult) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_OperationResult length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_OperationResult length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_OperationResult) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_OperationResult) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationResult, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_OperationResult) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_OperationResult(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_OperationResult) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (v *_XdrVec_unbounded_OperationResult) XdrPointer() interface{} { return (*[]OperationResult)(v) }
func (v _XdrVec_unbounded_OperationResult) XdrValue() interface{} { return ([]OperationResult)(v) }
func (v *_XdrVec_unbounded_OperationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionResult_Result) Results() *[]OperationResult {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		if v, ok := u._u.(*[]OperationResult); ok {
			return v
		} else {
			var zero []OperationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionResult_Result.Results accessed when Code == %v", u.Code)
		return nil
	}
}
func (u XdrAnon_TransactionResult_Result) XdrValid() bool {
	return true
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionTagName() string {
	return "Code"
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionBody() interface{} {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return u.Results()
	default:
		return nil
	}
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionBodyName() string {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return "Results"
	default:
		return ""
	}
}
func (v *XdrAnon_TransactionResult_Result) XdrPointer() interface{} { return v }
func (v XdrAnon_TransactionResult_Result) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionResult_Result) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionResult_Result) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TransactionResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_OperationResult)(u.Results()))
		return
	default:
		return
	}
}
func XDR_XdrAnon_TransactionResult_Result(v *XdrAnon_TransactionResult_Result) *XdrAnon_TransactionResult_Result { return v}
func (u XdrAnon_TransactionResult_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *XdrAnon_TransactionResult_Ext) XdrPointer() interface{} { return v }
func (v XdrAnon_TransactionResult_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionResult_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionResult_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionResult_Ext", u.V)
}
func XDR_XdrAnon_TransactionResult_Ext(v *XdrAnon_TransactionResult_Ext) *XdrAnon_TransactionResult_Ext { return v}
func (v *TransactionResult) XdrPointer() interface{} { return v }
func (v TransactionResult) XdrValue() interface{} { return v }
func (v *TransactionResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Int64(&v.FeeCharged).XdrMarshal(x, x.Sprintf("%sfeeCharged", name))
	XDR_XdrAnon_TransactionResult_Result(&v.Result).XdrMarshal(x, x.Sprintf("%sresult", name))
	XDR_XdrAnon_TransactionResult_Ext(&v.Ext).XdrMarshal(x, x.Sprintf("%sext", name))
}
func XDR_TransactionResult(v *TransactionResult) *TransactionResult { return v }
type _XdrTypedef_Hash struct {
	p *Hash
}
func (v _XdrTypedef_Hash) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Hash) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Hash) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Hash(string, *Hash)
	}); ok {
		xs.Marshal_Hash(name, v.p)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v.p)[:]))
	}
}
func XDR_Hash(v *Hash) _XdrTypedef_Hash {
	return _XdrTypedef_Hash{ v }
}
type _XdrTypedef_Uint256 struct {
	p *Uint256
}
func (v _XdrTypedef_Uint256) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Uint256) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Uint256) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Uint256(string, *Uint256)
	}); ok {
		xs.Marshal_Uint256(name, v.p)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v.p)[:]))
	}
}
func XDR_Uint256(v *Uint256) _XdrTypedef_Uint256 {
	return _XdrTypedef_Uint256{ v }
}
type _XdrTypedef_Uint32 struct {
	p *Uint32
}
func (v _XdrTypedef_Uint32) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Uint32) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Uint32) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Uint32(string, *Uint32)
	}); ok {
		xs.Marshal_Uint32(name, v.p)
	} else {
		XDR_uint32(v.p).XdrMarshal(x, name)
	}
}
func XDR_Uint32(v *Uint32) _XdrTypedef_Uint32 {
	return _XdrTypedef_Uint32{ v }
}
type _XdrTypedef_Int32 struct {
	p *Int32
}
func (v _XdrTypedef_Int32) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Int32) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Int32) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Int32(string, *Int32)
	}); ok {
		xs.Marshal_Int32(name, v.p)
	} else {
		XDR_int32(v.p).XdrMarshal(x, name)
	}
}
func XDR_Int32(v *Int32) _XdrTypedef_Int32 {
	return _XdrTypedef_Int32{ v }
}
type _XdrTypedef_Uint64 struct {
	p *Uint64
}
func (v _XdrTypedef_Uint64) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Uint64) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Uint64) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Uint64(string, *Uint64)
	}); ok {
		xs.Marshal_Uint64(name, v.p)
	} else {
		XDR_uint64(v.p).XdrMarshal(x, name)
	}
}
func XDR_Uint64(v *Uint64) _XdrTypedef_Uint64 {
	return _XdrTypedef_Uint64{ v }
}
type _XdrTypedef_Int64 struct {
	p *Int64
}
func (v _XdrTypedef_Int64) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Int64) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Int64) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Int64(string, *Int64)
	}); ok {
		xs.Marshal_Int64(name, v.p)
	} else {
		XDR_int64(v.p).XdrMarshal(x, name)
	}
}
func XDR_Int64(v *Int64) _XdrTypedef_Int64 {
	return _XdrTypedef_Int64{ v }
}
var _XdrNames_CryptoKeyType = map[int32]string{
	int32(KEY_TYPE_ED25519): "KEY_TYPE_ED25519",
	int32(KEY_TYPE_PRE_AUTH_TX): "KEY_TYPE_PRE_AUTH_TX",
	int32(KEY_TYPE_HASH_X): "KEY_TYPE_HASH_X",
}
var _XdrValues_CryptoKeyType = map[string]int32{
	"KEY_TYPE_ED25519": int32(KEY_TYPE_ED25519),
	"KEY_TYPE_PRE_AUTH_TX": int32(KEY_TYPE_PRE_AUTH_TX),
	"KEY_TYPE_HASH_X": int32(KEY_TYPE_HASH_X),
}
func (CryptoKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_CryptoKeyType
}
func (v CryptoKeyType) String() string {
	if s, ok := _XdrNames_CryptoKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CryptoKeyType#%d", v)
}
func (v *CryptoKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CryptoKeyType[stok]; ok {
			*v = CryptoKeyType(val)
			return nil
		} else if stok == "CryptoKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CryptoKeyType.", stok))
	}
}
func (v CryptoKeyType) GetU32() uint32 { return uint32(v) }
func (v *CryptoKeyType) SetU32(n uint32) { *v = CryptoKeyType(n) }
func (v *CryptoKeyType) XdrPointer() interface{} { return v }
func (v CryptoKeyType) XdrValue() interface{} { return v }
func (v *CryptoKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_CryptoKeyType(v *CryptoKeyType) *CryptoKeyType { return v }
var _XdrNames_PublicKeyType = map[int32]string{
	int32(PUBLIC_KEY_TYPE_ED25519): "PUBLIC_KEY_TYPE_ED25519",
}
var _XdrValues_PublicKeyType = map[string]int32{
	"PUBLIC_KEY_TYPE_ED25519": int32(PUBLIC_KEY_TYPE_ED25519),
}
func (PublicKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_PublicKeyType
}
func (v PublicKeyType) String() string {
	if s, ok := _XdrNames_PublicKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PublicKeyType#%d", v)
}
func (v *PublicKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PublicKeyType[stok]; ok {
			*v = PublicKeyType(val)
			return nil
		} else if stok == "PublicKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PublicKeyType.", stok))
	}
}
func (v PublicKeyType) GetU32() uint32 { return uint32(v) }
func (v *PublicKeyType) SetU32(n uint32) { *v = PublicKeyType(n) }
func (v *PublicKeyType) XdrPointer() interface{} { return v }
func (v PublicKeyType) XdrValue() interface{} { return v }
func (v *PublicKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_PublicKeyType(v *PublicKeyType) *PublicKeyType { return v }
var _XdrNames_SignerKeyType = map[int32]string{
	int32(SIGNER_KEY_TYPE_ED25519): "SIGNER_KEY_TYPE_ED25519",
	int32(SIGNER_KEY_TYPE_PRE_AUTH_TX): "SIGNER_KEY_TYPE_PRE_AUTH_TX",
	int32(SIGNER_KEY_TYPE_HASH_X): "SIGNER_KEY_TYPE_HASH_X",
}
var _XdrValues_SignerKeyType = map[string]int32{
	"SIGNER_KEY_TYPE_ED25519": int32(SIGNER_KEY_TYPE_ED25519),
	"SIGNER_KEY_TYPE_PRE_AUTH_TX": int32(SIGNER_KEY_TYPE_PRE_AUTH_TX),
	"SIGNER_KEY_TYPE_HASH_X": int32(SIGNER_KEY_TYPE_HASH_X),
}
func (SignerKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_SignerKeyType
}
func (v SignerKeyType) String() string {
	if s, ok := _XdrNames_SignerKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SignerKeyType#%d", v)
}
func (v *SignerKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SignerKeyType[stok]; ok {
			*v = SignerKeyType(val)
			return nil
		} else if stok == "SignerKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SignerKeyType.", stok))
	}
}
func (v SignerKeyType) GetU32() uint32 { return uint32(v) }
func (v *SignerKeyType) SetU32(n uint32) { *v = SignerKeyType(n) }
func (v *SignerKeyType) XdrPointer() interface{} { return v }
func (v SignerKeyType) XdrValue() interface{} { return v }
func (v *SignerKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_SignerKeyType(v *SignerKeyType) *SignerKeyType { return v }
func (u *PublicKey) Ed25519() *Uint256 {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PublicKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u PublicKey) XdrValid() bool {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return true
	}
	return false
}
func (u *PublicKey) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *PublicKey) XdrUnionTagName() string {
	return "Type"
}
func (u *PublicKey) XdrUnionBody() interface{} {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return u.Ed25519()
	}
	return nil
}
func (u *PublicKey) XdrUnionBodyName() string {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return "Ed25519"
	}
	return ""
}
func (v *PublicKey) XdrPointer() interface{} { return v }
func (v PublicKey) XdrValue() interface{} { return v }
func (v *PublicKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PublicKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PublicKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		XDR_Uint256(u.Ed25519()).XdrMarshal(x, x.Sprintf("%sed25519", name))
		return
	}
	XdrPanic("invalid Type (%v) in PublicKey", u.Type)
}
func XDR_PublicKey(v *PublicKey) *PublicKey { return v}
func (u *SignerKey) Ed25519() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
/* SHA-256 Hash of TransactionSignaturePayload structure */
func (u *SignerKey) PreAuthTx() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.PreAuthTx accessed when Type == %v", u.Type)
		return nil
	}
}
/* Hash of random 256 bit preimage X */
func (u *SignerKey) HashX() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_HASH_X:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.HashX accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SignerKey) XdrValid() bool {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519,SIGNER_KEY_TYPE_PRE_AUTH_TX,SIGNER_KEY_TYPE_HASH_X:
		return true
	}
	return false
}
func (u *SignerKey) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *SignerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *SignerKey) XdrUnionBody() interface{} {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return u.Ed25519()
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return u.PreAuthTx()
	case SIGNER_KEY_TYPE_HASH_X:
		return u.HashX()
	}
	return nil
}
func (u *SignerKey) XdrUnionBodyName() string {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return "Ed25519"
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return "PreAuthTx"
	case SIGNER_KEY_TYPE_HASH_X:
		return "HashX"
	}
	return ""
}
func (v *SignerKey) XdrPointer() interface{} { return v }
func (v SignerKey) XdrValue() interface{} { return v }
func (v *SignerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SignerKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignerKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		XDR_Uint256(u.Ed25519()).XdrMarshal(x, x.Sprintf("%sed25519", name))
		return
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		XDR_Uint256(u.PreAuthTx()).XdrMarshal(x, x.Sprintf("%spreAuthTx", name))
		return
	case SIGNER_KEY_TYPE_HASH_X:
		XDR_Uint256(u.HashX()).XdrMarshal(x, x.Sprintf("%shashX", name))
		return
	}
	XdrPanic("invalid Type (%v) in SignerKey", u.Type)
}
func XDR_SignerKey(v *SignerKey) *SignerKey { return v}
type _XdrTypedef_Signature struct {
	p *Signature
}
func (v _XdrTypedef_Signature) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_Signature) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_Signature) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_Signature(string, *Signature)
	}); ok {
		xs.Marshal_Signature(name, v.p)
	} else {
		x.Marshal(name, XdrVecOpaque{v.p, 64})
	}
}
func XDR_Signature(v *Signature) _XdrTypedef_Signature {
	return _XdrTypedef_Signature{ v }
}
type _XdrTypedef_SignatureHint struct {
	p *SignatureHint
}
func (v _XdrTypedef_SignatureHint) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_SignatureHint) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_SignatureHint) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_SignatureHint(string, *SignatureHint)
	}); ok {
		xs.Marshal_SignatureHint(name, v.p)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v.p)[:]))
	}
}
func XDR_SignatureHint(v *SignatureHint) _XdrTypedef_SignatureHint {
	return _XdrTypedef_SignatureHint{ v }
}
type _XdrTypedef_NodeID struct {
	p *NodeID
}
func (v _XdrTypedef_NodeID) XdrPointer() interface{} { return v.p }
func (v _XdrTypedef_NodeID) XdrValue() interface{} { return *v.p }
func (v _XdrTypedef_NodeID) XdrMarshal(x XDR, name string) {
	if xs, ok := x.(interface{
		Marshal_NodeID(string, *NodeID)
	}); ok {
		xs.Marshal_NodeID(name, v.p)
	} else {
		XDR_PublicKey(v.p).XdrMarshal(x, name)
	}
}
func XDR_NodeID(v *NodeID) _XdrTypedef_NodeID {
	return _XdrTypedef_NodeID{ v }
}
func (v *Curve25519Secret) XdrPointer() interface{} { return v }
func (v Curve25519Secret) XdrValue() interface{} { return v }
func (v *Curve25519Secret) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Curve25519Secret) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XdrArrayOpaque((v.Key)[:]))
}
func XDR_Curve25519Secret(v *Curve25519Secret) *Curve25519Secret { return v }
func (v *Curve25519Public) XdrPointer() interface{} { return v }
func (v Curve25519Public) XdrValue() interface{} { return v }
func (v *Curve25519Public) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Curve25519Public) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XdrArrayOpaque((v.Key)[:]))
}
func XDR_Curve25519Public(v *Curve25519Public) *Curve25519Public { return v }
func (v *HmacSha256Key) XdrPointer() interface{} { return v }
func (v HmacSha256Key) XdrValue() interface{} { return v }
func (v *HmacSha256Key) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *HmacSha256Key) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XdrArrayOpaque((v.Key)[:]))
}
func XDR_HmacSha256Key(v *HmacSha256Key) *HmacSha256Key { return v }
func (v *HmacSha256Mac) XdrPointer() interface{} { return v }
func (v HmacSha256Mac) XdrValue() interface{} { return v }
func (v *HmacSha256Mac) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *HmacSha256Mac) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%smac", name), XdrArrayOpaque((v.Mac)[:]))
}
func XDR_HmacSha256Mac(v *HmacSha256Mac) *HmacSha256Mac { return v }
